<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kazakhstan National Football Team Simulator</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 {
            color: #0057b7; /* Blue */
        }
        h1 {
            text-align: center;
            color: #0057b7;
            border-bottom: 2px solid #ffd700; /* Yellow */
            padding-bottom: 10px;
        }
        label {
            font-weight: bold;
            margin-right: 10px;
        }
        select, button {
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        button {
            background-color: #0057b7;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #003d80;
        }
        #results {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9eef3;
            border-radius: 5px;
            border: 1px solid #d1d9e0;
            min-height: 100px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #e0e0e0;
            font-weight: bold;
        }
        tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            background: #f0f0f0;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }
        .spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #0057b7; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üá∞üáø Kazakhstan National Football Team Simulator ‚öΩ</h1>

        <div>
            <label for="competition">Select Competition:</label>
            <select id="competition">
                <option value="friendly">Friendly Match</option>
                <option value="nations_league">Nations League</option>
                <option value="euro_qualifiers">EURO Qualifiers</option>
                <option value="euro">EURO Finals</option>
                <option value="wc_qualifiers">World Cup Qualifiers</option>
                <option value="world_cup">World Cup Finals</option>
            </select>
        </div>

        <button id="startButton">Start Simulation</button>

        <div id="results">
            <p>Select a competition and click "Start Simulation".</p>
        </div>
    </div>

    <script>
        // --- Data ---
        const teams = [
            { name: "Kazakhstan üá∞üáø", strength: 45, confederation: "UEFA" },
            // UEFA Teams (Selection)
            { name: "Germany üá©üá™", strength: 88, confederation: "UEFA" },
            { name: "France üá´üá∑", strength: 92, confederation: "UEFA" },
            { name: "Spain üá™üá∏", strength: 87, confederation: "UEFA" },
            { name: "England üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø", strength: 89, confederation: "UEFA" },
            { name: "Portugal üáµüáπ", strength: 88, confederation: "UEFA" },
            { name: "Belgium üáßüá™", strength: 86, confederation: "UEFA" },
            { name: "Italy üáÆüáπ", strength: 85, confederation: "UEFA" },
            { name: "Netherlands üá≥üá±", strength: 84, confederation: "UEFA" },
            { name: "Croatia üá≠üá∑", strength: 82, confederation: "UEFA" },
            { name: "Denmark üá©üá∞", strength: 78, confederation: "UEFA" },
            { name: "Switzerland üá®üá≠", strength: 77, confederation: "UEFA" },
            { name: "Austria üá¶üáπ", strength: 75, confederation: "UEFA" },
            { name: "Hungary üá≠üá∫", strength: 73, confederation: "UEFA" },
            { name: "Poland üáµüá±", strength: 72, confederation: "UEFA" },
            { name: "Serbia üá∑üá∏", strength: 71, confederation: "UEFA" },
            { name: "Sweden üá∏üá™", strength: 70, confederation: "UEFA" },
            { name: "Ukraine üá∫üá¶", strength: 68, confederation: "UEFA" },
            { name: "Wales üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø", strength: 65, confederation: "UEFA" },
            { name: "Turkey üáπüá∑", strength: 66, confederation: "UEFA" },
            { name: "Norway üá≥üá¥", strength: 64, confederation: "UEFA" },
            { name: "Scotland üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø", strength: 63, confederation: "UEFA" },
            { name: "Czech Republic üá®üáø", strength: 62, confederation: "UEFA" },
            { name: "Republic of Ireland üáÆüá™", strength: 58, confederation: "UEFA" },
            { name: "Greece üá¨üá∑", strength: 60, confederation: "UEFA" },
            { name: "Slovenia üá∏üáÆ", strength: 59, confederation: "UEFA" },
            { name: "Slovakia üá∏üá∞", strength: 55, confederation: "UEFA" },
            { name: "Romania üá∑üá¥", strength: 57, confederation: "UEFA" },
            { name: "Bosnia & Herzegovina üáßüá¶", strength: 56, confederation: "UEFA" },
            { name: "Finland üá´üáÆ", strength: 54, confederation: "UEFA" },
            { name: "Iceland üáÆüá∏", strength: 53, confederation: "UEFA" },
            { name: "North Macedonia üá≤üá∞", strength: 52, confederation: "UEFA" },
            { name: "Albania üá¶üá±", strength: 51, confederation: "UEFA" },
            { name: "Montenegro üá≤üá™", strength: 49, confederation: "UEFA" },
            { name: "Armenia üá¶üá≤", strength: 48, confederation: "UEFA" },
            { name: "Georgia üá¨üá™", strength: 50, confederation: "UEFA" },
            { name: "Luxembourg üá±üá∫", strength: 42, confederation: "UEFA" },
            { name: "Bulgaria üáßüá¨", strength: 44, confederation: "UEFA" },
            { name: "Northern Ireland üá¨üáß", strength: 46, confederation: "UEFA" },
            { name: "Azerbaijan üá¶üáø", strength: 40, confederation: "UEFA" },
            { name: "Kosovo üáΩüá∞", strength: 41, confederation: "UEFA" },
            { name: "Belarus üáßüáæ", strength: 39, confederation: "UEFA" },
            { name: "Cyprus üá®üáæ", strength: 38, confederation: "UEFA" },
            { name: "Estonia üá™üá™", strength: 37, confederation: "UEFA" },
            { name: "Latvia üá±üáª", strength: 36, confederation: "UEFA" },
            { name: "Faroe Islands üá´üá¥", strength: 35, confederation: "UEFA" },
            { name: "Lithuania üá±üáπ", strength: 34, confederation: "UEFA" },
            { name: "Moldova üá≤üá©", strength: 33, confederation: "UEFA" },
            { name: "Malta üá≤üáπ", strength: 30, confederation: "UEFA" },
            { name: "Andorra üá¶üá©", strength: 25, confederation: "UEFA" },
            { name: "Gibraltar üá¨üáÆ", strength: 15, confederation: "UEFA" },
            { name: "San Marino üá∏üá≤", strength: 10, confederation: "UEFA" },
            // Other Confederations (Selection for WC)
            { name: "Brazil üáßüá∑", strength: 93, confederation: "CONMEBOL" },
            { name: "Argentina üá¶üá∑", strength: 91, confederation: "CONMEBOL" },
            { name: "Uruguay üá∫üáæ", strength: 80, confederation: "CONMEBOL" },
            { name: "Colombia üá®üá¥", strength: 76, confederation: "CONMEBOL" },
            { name: "Chile üá®üá±", strength: 70, confederation: "CONMEBOL" },
            { name: "Peru üáµüá™", strength: 68, confederation: "CONMEBOL" },
            { name: "Ecuador üá™üá®", strength: 65, confederation: "CONMEBOL" },
            { name: "USA üá∫üá∏", strength: 74, confederation: "CONCACAF" },
            { name: "Mexico üá≤üáΩ", strength: 73, confederation: "CONCACAF" },
            { name: "Canada üá®üá¶", strength: 69, confederation: "CONCACAF" },
            { name: "Costa Rica üá®üá∑", strength: 60, confederation: "CONCACAF" },
            { name: "Panama üáµüá¶", strength: 55, confederation: "CONCACAF" },
            { name: "Japan üáØüáµ", strength: 75, confederation: "AFC" },
            { name: "South Korea üá∞üá∑", strength: 72, confederation: "AFC" },
            { name: "Iran üáÆüá∑", strength: 70, confederation: "AFC" },
            { name: "Australia üá¶üá∫", strength: 67, confederation: "AFC" },
            { name: "Saudi Arabia üá∏üá¶", strength: 62, confederation: "AFC" },
            { name: "Qatar üá∂üá¶", strength: 60, confederation: "AFC" },
            { name: "Senegal üá∏üá≥", strength: 79, confederation: "CAF" },
            { name: "Morocco üá≤üá¶", strength: 81, confederation: "CAF" },
            { name: "Nigeria üá≥üá¨", strength: 65, confederation: "CAF" },
            { name: "Egypt üá™üá¨", strength: 64, confederation: "CAF" },
            { name: "Algeria üá©üáø", strength: 63, confederation: "CAF" },
            { name: "Tunisia üáπüá≥", strength: 61, confederation: "CAF" },
            { name: "Cameroon üá®üá≤", strength: 59, confederation: "CAF" },
            { name: "Ghana üá¨üá≠", strength: 58, confederation: "CAF" },
            { name: "New Zealand üá≥üáø", strength: 45, confederation: "OFC" },
        ];
        const KAZAKHSTAN = teams.find(t => t.name.includes("Kazakhstan"));

        // --- Simulation Logic ---
        function simulateMatch(team1, team2) {
            const strengthDiff = team1.strength - team2.strength;
            const maxGoals = 6; // Max goals per team per match
            const avgGoals = 1.35; // Average goals per team in a match
            const strengthFactor = 0.025; // How much strength affects goals
            const randomnessFactor = 0.7; // How much randomness (0 to 1)

            let expectedGoals1 = avgGoals + strengthFactor * (team1.strength - 55) + strengthFactor * strengthDiff / 2;
            let expectedGoals2 = avgGoals + strengthFactor * (team2.strength - 55) - strengthFactor * strengthDiff / 2;

            expectedGoals1 = Math.max(0.1, expectedGoals1);
            expectedGoals2 = Math.max(0.1, expectedGoals2);

            // Poisson distribution approximation for generating goals
            const L1 = Math.exp(-expectedGoals1 * (1 + (Math.random() - 0.5) * randomnessFactor));
            const L2 = Math.exp(-expectedGoals2 * (1 + (Math.random() - 0.5) * randomnessFactor));

            let k1 = 0;
            let p1 = 1;
            do {
                k1++;
                p1 *= Math.random();
            } while (p1 > L1 && k1 <= maxGoals + 2); // Allow slightly higher intermediate calc
            let goals1 = k1 - 1;

            let k2 = 0;
            let p2 = 1;
            do {
                k2++;
                p2 *= Math.random();
            } while (p2 > L2 && k2 <= maxGoals + 2);
            let goals2 = k2 - 1;

            // Cap goals strictly at maxGoals
            goals1 = Math.min(goals1, maxGoals);
            goals2 = Math.min(goals2, maxGoals);

            return { score1: goals1, score2: goals2 };
        }

        function runFriendly() {
            let output = `<h2>Friendly Match Result</h2>`;
            const opponentPool = teams.filter(t => t !== KAZAKHSTAN);
            if (opponentPool.length === 0) return "<p>Error: No opponents available.</p>";
            const opponent = opponentPool[Math.floor(Math.random() * opponentPool.length)];
            const result = simulateMatch(KAZAKHSTAN, opponent);
            output += `<p>${KAZAKHSTAN.name} ${result.score1} - ${result.score2} ${opponent.name}</p>`;
            return output;
        }

        // Helper for group stage simulation
        function simulateGroupStage(group, isDoubleRoundRobin = true) {
            const standings = {};
            group.forEach(team => {
                standings[team.name] = { team: team, P: 0, W: 0, D: 0, L: 0, GF: 0, GA: 0, GD: 0, Pts: 0 };
            });
            let matchResults = "<h3>Group Matches</h3><ul>";

            for (let i = 0; i < group.length; i++) {
                for (let j = i + 1; j < group.length; j++) {
                    const team1 = group[i];
                    const team2 = group[j];

                    // Match 1: Team1 vs Team2
                    const result1 = simulateMatch(team1, team2);
                    matchResults += `<li>${team1.name} ${result1.score1} - ${result1.score2} ${team2.name}</li>`;
                    updateStandings(standings, team1, team2, result1.score1, result1.score2);

                    if (isDoubleRoundRobin) {
                        // Match 2: Team2 vs Team1
                        const result2 = simulateMatch(team2, team1);
                        matchResults += `<li>${team2.name} ${result2.score1} - ${result2.score2} ${team1.name}</li>`;
                        updateStandings(standings, team2, team1, result2.score1, result2.score2);
                    }
                }
            }
            matchResults += "</ul>";

            // Tie-breaking rules (simplified: Points -> GD -> GF -> Random)
            const sortedStandings = Object.values(standings).sort((a, b) => {
                if (b.Pts !== a.Pts) return b.Pts - a.Pts;
                if (b.GD !== a.GD) return b.GD - a.GD;
                if (b.GF !== a.GF) return b.GF - a.GF;
                // Add head-to-head comparison? (Complex)
                return Math.random() - 0.5; // Random tiebreaker as last resort
            });

            return { standings: sortedStandings, results: matchResults };
        }

        function updateStandings(standings, team1, team2, score1, score2) {
            const s1 = standings[team1.name];
            const s2 = standings[team2.name];

            s1.P++;
            s2.P++;
            s1.GF += score1;
            s1.GA += score2;
            s2.GF += score2;
            s2.GA += score1;
            s1.GD = s1.GF - s1.GA;
            s2.GD = s2.GF - s2.GA;

            if (score1 > score2) {
                s1.W++;
                s1.Pts += 3;
                s2.L++;
            } else if (score2 > score1) {
                s2.W++;
                s2.Pts += 3;
                s1.L++;
            } else {
                s1.D++;
                s2.D++;
                s1.Pts += 1;
                s2.Pts += 1;
            }
        }

        function displayStandings(standings) {
            let table = `<h3>Group Standings</h3>
                         <table>
                           <thead>
                             <tr><th>#</th><th>Team</th><th>P</th><th>W</th><th>D</th><th>L</th><th>GF</th><th>GA</th><th>GD</th><th>Pts</th></tr>
                           </thead>
                           <tbody>`;
            standings.forEach((s, index) => {
                // Highlight Kazakhstan row
                const isKazakhstan = s.team === KAZAKHSTAN;
                table += `<tr style="${isKazakhstan ? 'background-color: #fff3cd; font-weight: bold;' : ''}">
                            <td>${index + 1}</td>
                            <td>${s.team.name}</td>
                            <td>${s.P}</td>
                            <td>${s.W}</td>
                            <td>${s.D}</td>
                            <td>${s.L}</td>
                            <td>${s.GF}</td>
                            <td>${s.GA}</td>
                            <td>${s.GD}</td>
                            <td><b>${s.Pts}</b></td>
                          </tr>`;
            });
            table += `</tbody></table>`;
            return table;
        }

        function generateGroups(teamPool, numGroups, groupSize) {
             // Simplified seeding: Sort by strength and distribute
             const sortedTeams = [...teamPool].sort((a, b) => b.strength - a.strength);
             const groups = Array.from({ length: numGroups }, () => []);
             const pots = [];
             for (let i = 0; i < numGroups; i++) {
                 pots.push(sortedTeams.slice(i * groupSize, (i+1) * groupSize)); // Incorrect pot creation, should be depth-wise
             }

             // Corrected Pot Creation (Pot 1 has top N teams, Pot 2 next N, etc.)
             const correctPots = Array.from({ length: groupSize }, () => []);
             for(let i=0; i<sortedTeams.length; i++){
                 correctPots[i % groupSize].push(sortedTeams[i]);
             }

             // Shuffle within pots and distribute
             correctPots.forEach(pot => {
                 const shuffledPot = [...pot].sort(() => Math.random() - 0.5);
                 shuffledPot.forEach((team, index) => {
                     if (groups[index % numGroups]) { // Ensure group exists
                         groups[index % numGroups].push(team);
                     }
                 });
             });


             // Ensure groups are not oversized and handle remainders
             const finalGroups = groups.map(g => g.slice(0, groupSize));
             let teamIndex = numGroups * groupSize; // Index of teams not yet placed
             // Distribute remaining teams if any group has space (due to uneven numbers)
             while(teamIndex < sortedTeams.length) {
                 for(let i = 0; i < numGroups; i++) {
                     if (finalGroups[i].length < groupSize && teamIndex < sortedTeams.length) {
                         finalGroups[i].push(sortedTeams[teamIndex]);
                         teamIndex++;
                     }
                 }
                 if (teamIndex < sortedTeams.length && finalGroups.every(g => g.length === groupSize)) break; // Stop if all groups full
             }


             // Ensure Kazakhstan is in a group if they were in the pool
            if (teamPool.includes(KAZAKHSTAN)) {
                let kazInGroup = finalGroups.some(g => g.includes(KAZAKHSTAN));
                if (!kazInGroup && finalGroups.length > 0) {
                    // Swap with a random team in a random group (preferrably lowest strength team in a group)
                    const randomGroupIdx = Math.floor(Math.random() * finalGroups.length);
                    if (finalGroups[randomGroupIdx].length > 0) {
                        // Find lowest strength team to replace
                        let minStrength = 200;
                        let replaceIdx = 0;
                        finalGroups[randomGroupIdx].forEach((t, idx) => {
                            if(t.strength < minStrength) {
                                minStrength = t.strength;
                                replaceIdx = idx;
                            }
                        });
                        // Ensure not replacing KAZ itself if it somehow got there but flag missed it
                        if(finalGroups[randomGroupIdx][replaceIdx] !== KAZAKHSTAN) {
                           finalGroups[randomGroupIdx][replaceIdx] = KAZAKHSTAN;
                        } else if (finalGroups[randomGroupIdx].length > 1) {
                            // If lowest is KAZ, replace the next lowest (or just random if only 2 teams)
                             const swapTargetIdx = (replaceIdx === 0 && finalGroups[randomGroupIdx].length > 1) ? 1 : 0;
                             finalGroups[randomGroupIdx][swapTargetIdx] = KAZAKHSTAN;
                        }

                    } else {
                         // Group was empty, just add KAZ
                         finalGroups[randomGroupIdx].push(KAZAKHSTAN);
                    }
                }
            }


            // Filter out empty groups if any were created
            return finalGroups.filter(g => g.length > 0);
        }


        // --- Competition Specific Logic ---

        function runQualifiers(competitionName, totalTeamsInQualifiers, teamsPerGroupMax, numQualifyingSpotsDirect, numPlayoffSpots = 0, playoffQualifyingSpots = 0) {
            let output = `<h2>${competitionName} Qualifiers</h2>`;
            const uefaTeams = teams.filter(t => t.confederation === "UEFA");
            // Ensure KAZ is treated as UEFA for these sims
            if (!uefaTeams.find(t => t.name === KAZAKHSTAN.name)) {
                 uefaTeams.push(KAZAKHSTAN); // Add if missing
            } else {
                 // Ensure the KAZ object is the one from the main 'teams' array if duplicated
                 const kazIndex = uefaTeams.findIndex(t => t.name === KAZAKHSTAN.name);
                 if (kazIndex > -1 && uefaTeams[kazIndex] !== KAZAKHSTAN) {
                     uefaTeams[kazIndex] = KAZAKHSTAN;
                 }
            }


            // Select the correct number of UEFA teams for qualifiers, ensuring KAZ is included
            let qualifierTeamsPool = [...uefaTeams].sort((a, b) => b.strength - a.strength); // Start sorted for potential seeding later
            qualifierTeamsPool = qualifierTeamsPool.slice(0, totalTeamsInQualifiers);

             // If KAZ wasn't in the top N, swap it with the weakest team included
             if (!qualifierTeamsPool.includes(KAZAKHSTAN) && uefaTeams.includes(KAZAKHSTAN)) {
                 if (qualifierTeamsPool.length > 0) {
                    qualifierTeamsPool[qualifierTeamsPool.length - 1] = KAZAKHSTAN; // Replace the last (weakest) team
                 } else {
                     qualifierTeamsPool.push(KAZAKHSTAN); // Add if pool was empty
                 }
             }
             qualifierTeamsPool = qualifierTeamsPool.sort(() => Math.random() - 0.5); // Shuffle before grouping


            const numGroups = Math.ceil(qualifierTeamsPool.length / teamsPerGroupMax);
            const groups = generateGroups(qualifierTeamsPool, numGroups, teamsPerGroupMax);

            const directQualifiers = [];
            const playoffTeams = [];
            let kazakhstanQualifiedDirectly = false;
            let kazakhstanPlayoffs = false;
            let kazGroupStandings = null;
            let kazGroupRank = -1;
            const allGroupStandings = [];


            groups.forEach((group, index) => {
                output += `<h3>Group ${String.fromCharCode(65 + index)}</h3>`;
                if (group.length < 2) {
                    output += "<p>Not enough teams to simulate matches in this group.</p>";
                    return;
                }
                const { standings, results } = simulateGroupStage(group, true); // Qualifiers are double round robin
                allGroupStandings.push({ groupIndex: index, standings });
                output += displayStandings(standings);
                output += results;

                // Determine qualifiers (e.g., top 1 qualifies, 2nd goes to playoffs)
                if (standings.length > 0) {
                    directQualifiers.push(standings[0].team);
                     if(standings[0].team === KAZAKHSTAN) kazakhstanQualifiedDirectly = true;
                }
                if (numPlayoffSpots > 0 && standings.length > 1) {
                    playoffTeams.push({ team: standings[1].team, groupRank: 2, groupPts: standings[1].Pts, groupGD: standings[1].GD }); // Store some context
                     if(standings[1].team === KAZAKHSTAN) kazakhstanPlayoffs = true;
                }
                if (group.includes(KAZAKHSTAN)) {
                    kazGroupStandings = standings;
                    kazGroupRank = standings.findIndex(s => s.team === KAZAKHSTAN) + 1;
                }
            });

            // Handle potential qualifiers via Nations League performance (Simplified: add top NL teams not already qualified/in playoffs)
            // This part is complex, skipping detailed NL path simulation for now.


             // Adjust direct qualifiers if needed (e.g. only N group winners)
             const finalDirectQualifiers = directQualifiers.slice(0, numQualifyingSpotsDirect);
             kazakhstanQualifiedDirectly = finalDirectQualifiers.includes(KAZAKHSTAN); // Re-check if KAZ made the cut

             // Select best runners-up for playoffs if needed
             const sortedPlayoffTeams = playoffTeams.sort((a, b) => {
                if (b.groupPts !== a.groupPts) return b.groupPts - a.groupPts;
                if (b.groupGD !== a.groupGD) return b.groupGD - a.groupGD;
                return Math.random() - 0.5;
             }).map(pt => pt.team); // Get just the team objects

             const finalPlayoffTeams = sortedPlayoffTeams.slice(0, numPlayoffSpots);
             kazakhstanPlayoffs = finalPlayoffTeams.includes(KAZAKHSTAN); // Re-check if KAZ made the playoff cut

            // Simulate playoffs
            let playoffQualifiers = [];
            let kazakhstanQualifiedViaPlayoffs = false;
            if (numPlayoffSpots > 0 && playoffQualifyingSpots > 0 && finalPlayoffTeams.length >= 2) {
                output += `<h3>Playoffs</h3>`;
                // Simulate semi-finals and finals structure (simplified pairings)
                let currentPlayoffTeams = [...finalPlayoffTeams];
                let playoffRound = 1;
                while(currentPlayoffTeams.length > playoffQualifyingSpots && currentPlayoffTeams.length >= 2) {
                     output += `<h4>Playoff Round ${playoffRound}</h4>`;
                     const winners = [];
                     const shuffledPlayoffTeams = currentPlayoffTeams.sort(() => Math.random() - 0.5);

                     for (let i = 0; i < Math.floor(shuffledPlayoffTeams.length / 2) * 2; i += 2) {
                         const teamA = shuffledPlayoffTeams[i];
                         const teamB = shuffledPlayoffTeams[i + 1];
                         // Simulate single knockout match for playoffs
                         let result = simulateMatch(teamA, teamB);
                         let winner, scoreString = `${result.score1} - ${result.score2}`;
                         if (result.score1 > result.score2) winner = teamA;
                         else if (result.score2 > result.score1) winner = teamB;
                         else { // Draw -> Random winner for simplicity
                              winner = (Math.random() < 0.5) ? teamA : teamB;
                              scoreString += " (Draw - Random Decider)";
                         }
                         output += `<p>${teamA.name} ${scoreString} ${teamB.name} -> <b>Winner: ${winner.name}</b></p>`;
                         winners.push(winner);
                     }
                     // Handle odd team out? Simplification: they don't advance
                     currentPlayoffTeams = winners;
                     playoffRound++;
                     if (playoffRound > 5) break; // Safety break
                }
                playoffQualifiers = currentPlayoffTeams.slice(0, playoffQualifyingSpots); // Take the required number of winners
                kazakhstanQualifiedViaPlayoffs = playoffQualifiers.includes(KAZAKHSTAN);
            }


            const allQualifiedTeams = [...finalDirectQualifiers, ...playoffQualifiers];
            const kazakhstanQualifiedOverall = kazakhstanQualifiedDirectly || kazakhstanQualifiedViaPlayoffs;

            output += `<h2>Qualification Result for ${competitionName}</h2>`;
            if (kazGroupRank !== -1) {
                 output += `<p>Kazakhstan finished ${kazGroupRank + getOrdinalSuffix(kazGroupRank)} in their group.</p>`;
            } else {
                output += `<p>Kazakhstan was not placed in a group (Error or pool size issue).</p>`;
            }

            if (kazakhstanQualifiedDirectly) {
                output += `<p style="color: green; font-weight: bold;">üéâ Kazakhstan has qualified directly! üéâ</p>`;
            } else if (kazakhstanPlayoffs && kazakhstanQualifiedViaPlayoffs) {
                output += `<p style="color: green; font-weight: bold;">üéâ Kazakhstan has qualified via the playoffs! üéâ</p>`;
            } else if (kazakhstanPlayoffs && !kazakhstanQualifiedViaPlayoffs) {
                 output += `<p style="color: orange; font-weight: bold;">üá∞üáø Kazakhstan reached the playoffs but did not qualify.</p>`;
            } else {
                output += `<p style="color: red; font-weight: bold;">üá∞üáø Kazakhstan did not qualify.</p>`;
            }

            output += `<h3>Qualified Teams (${allQualifiedTeams.length})</h3><ul>`;
            allQualifiedTeams.forEach(team => {
                output += `<li>${team.name} ${finalDirectQualifiers.includes(team) ? '(Direct)' : '(Playoff)'}</li>`;
            });
            output += `</ul>`;

            return { output, qualifiedTeams: allQualifiedTeams, didKazakhstanQualify: kazakhstanQualifiedOverall };
        }

        function getOrdinalSuffix(i) {
            const j = i % 10, k = i % 100;
            if (j == 1 && k != 11) return "st";
            if (j == 2 && k != 12) return "nd";
            if (j == 3 && k != 13) return "rd";
            return "th";
        }


        function runNationsLeague() {
            let output = `<h2>UEFA Nations League</h2>`;
            const uefaTeams = teams.filter(t => t.confederation === "UEFA");
            if (!uefaTeams.find(t => t.name === KAZAKHSTAN.name)) {
                 uefaTeams.push(KAZAKHSTAN);
            } else {
                 const kazIndex = uefaTeams.findIndex(t => t.name === KAZAKHSTAN.name);
                 if (kazIndex > -1 && uefaTeams[kazIndex] !== KAZAKHSTAN) uefaTeams[kazIndex] = KAZAKHSTAN;
            }

            // Leagues based on current UEFA rankings approx (16 A, 16 B, 16 C, rest D)
            const sortedUefaTeams = [...uefaTeams].sort((a, b) => b.strength - a.strength);
            const leagues = { A: [], B: [], C: [], D: [] };
            let currentLeague = 'A';
            let countInLeague = 0;

            sortedUefaTeams.forEach(team => {
                leagues[currentLeague].push(team);
                countInLeague++;
                if (currentLeague === 'A' && countInLeague === 16) { currentLeague = 'B'; countInLeague = 0; }
                else if (currentLeague === 'B' && countInLeague === 16) { currentLeague = 'C'; countInLeague = 0; }
                else if (currentLeague === 'C' && countInLeague === 16) { currentLeague = 'D'; countInLeague = 0; }
            });


            let kazLeague = null;
            for (const league in leagues) {
                if (leagues[league].includes(KAZAKHSTAN)) {
                    kazLeague = league;
                    break;
                }
            }
             output += `<p>Kazakhstan is competing in League ${kazLeague || 'Unknown (Error?)'}.</p>`;

            const groupSize = 4; // Typical group size

            for (const league in leagues) {
                output += `<h3>League ${league}</h3>`;
                const leagueTeams = leagues[league];
                if (leagueTeams.length === 0) continue; // Skip empty leagues

                const numGroups = Math.ceil(leagueTeams.length / groupSize);
                // Use strength-based seeding for NL groups too
                const groups = generateGroups(leagueTeams, numGroups, groupSize);

                groups.forEach((group, index) => {
                    output += `<h4>League ${league} - Group ${index + 1}</h4>`;
                     if (group.length < 2) {
                        output += "<p>Not enough teams to simulate matches in this group.</p>";
                        return;
                    }
                    const { standings, results } = simulateGroupStage(group, true); // NL is double round robin
                    output += displayStandings(standings);
                    output += results;

                    // Promotion/Relegation/Finals logic
                    const kazStanding = standings.find(s => s.team === KAZAKHSTAN);
                    if (kazStanding) {
                         const kazRank = standings.findIndex(s => s.team === KAZAKHSTAN) + 1;
                         const isLastPlace = kazRank === group.length; // Simplistic relegation check

                         if (kazRank === 1) { // Group Winner
                             if (league === 'A') {
                                output += `<p style="color: blue; font-weight: bold;">üèÜüá∞üáø Kazakhstan wins League A group! Advances to Nations League Finals (not simulated).</p>`;
                             } else {
                                output += `<p style="color: green; font-weight: bold;">‚¨ÜÔ∏èüá∞üáø Kazakhstan is PROMOTED to League ${String.fromCharCode(league.charCodeAt(0) - 1)}!</p>`;
                             }
                         } else if (isLastPlace && league !== 'D') { // Relegated
                             output += `<p style="color: red; font-weight: bold;">‚¨áÔ∏èüá∞üáø Kazakhstan is RELEGATED to League ${String.fromCharCode(league.charCodeAt(0) + 1)}!</p>`;
                         } else { // Stays in league
                             output += `<p>üá∞üáø Kazakhstan finishes ${kazRank + getOrdinalSuffix(kazRank)} and remains in League ${league}.</p>`;
                         }
                    }
                });
            }

            return output;
        }


        function simulateKnockoutStage(teams, roundName, outputPrefix = "") {
             let output = outputPrefix + `<h3>${roundName}</h3>`;
             const winners = [];
             const shuffledTeams = [...teams].sort(() => Math.random() - 0.5);

             if (shuffledTeams.length % 2 !== 0 && roundName !== "Final") {
                 // Give a bye in early rounds if odd number? Simplification: Drop last team
                 output += `<p>Warning: Odd number of teams (${shuffledTeams.length}) for ${roundName}. One team might not play.</p>`;
             }

             for (let i = 0; i < Math.floor(shuffledTeams.length / 2) * 2; i += 2) {
                 const teamA = shuffledTeams[i];
                 const teamB = shuffledTeams[i + 1];

                 // Single knockout match
                 let result = simulateMatch(teamA, teamB);
                 let winner, loser;
                 let scoreString = `${result.score1} - ${result.score2}`;

                 if (result.score1 > result.score2) {
                     winner = teamA; loser = teamB;
                 } else if (result.score2 > result.score1) {
                     winner = teamB; loser = teamA;
                 } else {
                     // Draw -> Extra Time / Penalties (Simplified: Random winner)
                     scoreString += " (AET/Pens - Random Decider)";
                     winner = (Math.random() < 0.5) ? teamA : teamB;
                     loser = (winner === teamA) ? teamB : teamA;
                 }
                 output += `<p>${teamA.name} ${scoreString} ${teamB.name} ‚û§ <b>Winner: ${winner.name}</b></p>`;
                 winners.push(winner);
             }

             return { output, winners };
         }

        function runFinalTournament(tournamentName, qualifiedTeamsInput, groupSize, numGroups, knockoutStartRound = 16) {
            let output = `<h2>${tournamentName} Finals Simulation</h2>`;
            const finalTournamentSize = numGroups * groupSize;

             if (qualifiedTeamsInput.length < finalTournamentSize) {
                 output += `<p style="color: orange;">Warning: Only ${qualifiedTeamsInput.length} teams provided, but ${finalTournamentSize} needed. Padding with random teams...</p>`;
                 // Pad with random teams not already included
                 const currentNames = new Set(qualifiedTeamsInput.map(t => t.name));
                 const potentialPadding = teams.filter(t => !currentNames.has(t.name));
                 potentialPadding.sort(() => Math.random() - 0.5);
                 const needed = finalTournamentSize - qualifiedTeamsInput.length;
                 qualifiedTeamsInput.push(...potentialPadding.slice(0, needed));
             }
             // Ensure exactly the right number
             const tournamentTeams = qualifiedTeamsInput.slice(0, finalTournamentSize);


            const containsKazakhstan = tournamentTeams.some(t => t.name.includes("Kazakhstan"));
            if (containsKazakhstan) {
                 output += `<p style="color: green; font-weight: bold;">üá∞üáø Kazakhstan is participating in the ${tournamentName}!</p>`;
            } else {
                 output += `<p>üá∞üáø Kazakhstan did not qualify for the ${tournamentName}. Simulating without them.</p>`;
            }

             output += `<h3>Group Stage</h3>`;
             // Use strength seeding for final tournament groups
             const groups = generateGroups(tournamentTeams, numGroups, groupSize);
             const groupStandingsList = []; // To calculate best 3rd place teams if needed

             groups.forEach((group, index) => {
                 output += `<h4>Group ${String.fromCharCode(65 + index)}</h4>`;
                  if (group.length < 2) {
                    output += "<p>Not enough teams to simulate matches in this group.</p>";
                    return;
                 }
                 // Finals group stage is single round robin
                 const { standings, results } = simulateGroupStage(group, false);
                 groupStandingsList.push(standings);
                 output += displayStandings(standings);
                 output += results;
             });

             // Determine knockout teams
             let knockoutTeams = [];
             const thirdPlaceTeams = [];
             groupStandingsList.forEach(standings => {
                if(standings.length > 0) knockoutTeams.push(standings[0].team); // Group Winners
                if(standings.length > 1) knockoutTeams.push(standings[1].team); // Group Runners-up
                if(standings.length > 2) thirdPlaceTeams.push(standings[2]);   // Potential 3rd place teams
             });

             // Add best 3rd place teams if needed (e.g., for 24-team Euro -> 16 knockout)
             const neededKnockoutTeams = knockoutStartRound;
             if (knockoutTeams.length < neededKnockoutTeams) {
                  const numThirdPlaceNeeded = neededKnockoutTeams - knockoutTeams.length;
                  // Sort 3rd place teams by points -> GD -> GF -> Random
                   thirdPlaceTeams.sort((a, b) => {
                        if (b.Pts !== a.Pts) return b.Pts - a.Pts;
                        if (b.GD !== a.GD) return b.GD - a.GD;
                        if (b.GF !== a.GF) return b.GF - a.GF;
                        return Math.random() - 0.5;
                   });
                   const bestThirdPlaceTeams = thirdPlaceTeams.slice(0, numThirdPlaceNeeded).map(s => s.team);
                   knockoutTeams.push(...bestThirdPlaceTeams);
                   output += `<p>Advanced ${bestThirdPlaceTeams.length} best 3rd-placed teams to knockout stage.</p>`;
             }
             // Ensure exact number for knockout round
             if(knockoutTeams.length !== neededKnockoutTeams) {
                 output += `<p style="color: orange;">Warning: Could not form exact number of teams (${neededKnockoutTeams}) for knockout round. Proceeding with ${knockoutTeams.length}.</p>`;
                 // Trim if too many?
                 knockoutTeams = knockoutTeams.slice(0, neededKnockoutTeams);
             }


             output += `<h2>Knockout Stage</h2>`;
             let currentTeams = [...knockoutTeams];
             let round = knockoutStartRound;
             let kazakhstanEliminated = !containsKazakhstan;
             let kazEliminationRound = null;

             while (currentTeams.length > 1 && round >= 1) {
                 let roundName = "";
                 if (round === 16) roundName = "Round of 16";
                 else if (round === 8) roundName = "Quarter-Finals";
                 else if (round === 4) roundName = "Semi-Finals";
                 else if (round === 2) roundName = "Final";
                 else roundName = `Round of ${round}`; // Fallback

                 const { output: roundOutput, winners } = simulateKnockoutStage(currentTeams, roundName);
                 output += roundOutput;

                 // Check if Kazakhstan was eliminated
                 if (!kazakhstanEliminated) {
                     const kazInCurrent = currentTeams.some(t => t.name.includes("Kazakhstan"));
                     const kazInWinners = winners.some(t => t.name.includes("Kazakhstan"));
                     if (kazInCurrent && !kazInWinners) {
                         kazakhstanEliminated = true;
                         kazEliminationRound = roundName;
                     }
                 }

                 currentTeams = winners;
                 round /= 2;

                 if (currentTeams.length === 1) break; // Stop when winner found
                 if (round < 1 || currentTeams.length < 2) break; // Safety breaks
             }

             // Declare winner
             if (currentTeams.length === 1) {
                 output += `<h2 style="text-align: center; margin-top: 20px;">üèÜ ${tournamentName} Winner: ${currentTeams[0].name} üèÜ</h2>`;
                  if (currentTeams[0] === KAZAKHSTAN) {
                      output += `<h1 style="color: gold; text-align: center; font-size: 2em;">üá∞üáø KAZAKHSTAN ARE ${tournamentName.toUpperCase()} CHAMPIONS!!! üá∞üáø</h1>`;
                  }
             } else {
                  output += `<h2 style="color: orange;">Tournament ended inconclusively (Could not determine single winner).</h2>`;
             }

             // Report Kazakhstan's fate
             if(containsKazakhstan) {
                 if (kazakhstanEliminated && kazEliminationRound) {
                     output += `<p style="margin-top: 15px;">üá∞üáø Kazakhstan was eliminated in the ${kazEliminationRound}.</p>`;
                 } else if (!kazakhstanEliminated && currentTeams.length === 1 && currentTeams[0] !== KAZAKHSTAN) {
                      // Should not happen if KAZ wasn't eliminated and didn't win
                      output += `<p style="margin-top: 15px;">üá∞üáø Kazakhstan finished the tournament, but was not the winner (status unclear).</p>`;
                 } else if (!kazakhstanEliminated && currentTeams.length !== 1) {
                      output += `<p style="margin-top: 15px;">üá∞üáø Kazakhstan was still in the tournament when it ended inconclusively.</p>`;
                 }
                 // Win case handled above
             }


             return output;
        }


        // --- Main Event Listener ---
        document.addEventListener('DOMContentLoaded', () => {
            const startButton = document.getElementById('startButton');
            const resultsDiv = document.getElementById('results');
            const competitionSelector = document.getElementById('competition');

            startButton.addEventListener('click', () => {
                const selectedCompetition = competitionSelector.value;
                resultsDiv.innerHTML = `<p>Simulating ${competitionSelector.options[competitionSelector.selectedIndex].text}...</p> <div class="spinner"></div>`;
                startButton.disabled = true; // Disable button during simulation

                // Use setTimeout to allow UI update and prevent freezing
                setTimeout(() => {
                    let simulationOutput = "";
                    try {
                         switch (selectedCompetition) {
                            case 'friendly':
                                simulationOutput = runFriendly();
                                break;
                            case 'wc_qualifiers':
                                {
                                    // FIFA WC Qualifiers (UEFA): 50+ teams, 10 groups (approx 5/6 teams), 10 direct spots + 3 playoff spots (12 teams in playoffs)
                                    const qualResult = runQualifiers("World Cup", 54, 6, 10, 12, 3);
                                    simulationOutput = qualResult.output;
                                }
                                break;
                            case 'euro_qualifiers':
                                 {
                                    // UEFA EURO Qualifiers: 50+ teams, 10 groups (approx 5/6 teams), 20 direct spots (top 2) + 3 playoff spots (via NL path - simplified) + host
                                     const qualResult = runQualifiers("EURO", 53, 6, 20, 12, 3); // Simplified playoffs
                                    simulationOutput = qualResult.output;
                                 }
                                break;
                            case 'nations_league':
                                simulationOutput = runNationsLeague();
                                break;
                            case 'world_cup':
                                {
                                    let outputWC = "<h2>World Cup Simulation</h2>";
                                     // 1. Run UEFA Qualifiers
                                     outputWC += "<p>Running UEFA Qualifiers...</p>";
                                     const uefaQualResult = runQualifiers("World Cup (UEFA Path)", 54, 6, 10, 12, 3); // 13 UEFA spots total
                                     outputWC += uefaQualResult.output;

                                     // 2. Gather qualified teams + Add teams from other confederations (simplified selection)
                                     let wcTeams = [...uefaQualResult.qualifiedTeams];
                                     const otherConfTeams = teams.filter(t => t.confederation !== "UEFA")
                                                               .sort((a, b) => b.strength - a.strength);

                                     const spotsRemaining = 32 - wcTeams.length; // WC has 32 teams
                                     wcTeams.push(...otherConfTeams.slice(0, spotsRemaining));

                                     // Ensure 32 teams
                                     while (wcTeams.length < 32 && teams.length > wcTeams.length) {
                                          const randomTeam = teams[Math.floor(Math.random()*teams.length)];
                                          if (!wcTeams.some(t => t.name === randomTeam.name)) wcTeams.push(randomTeam);
                                     }
                                     wcTeams = wcTeams.slice(0, 32);

                                     outputWC += `<p>Formed final 32 teams for World Cup.</p>`;

                                     // 3. Run the final tournament
                                     // Check if KAZ is in the final list (either qualified or added randomly)
                                     const kazInFinals = wcTeams.some(t => t.name === KAZAKHSTAN.name);
                                     outputWC += runFinalTournament("World Cup", wcTeams, 4, 8, 16); // 32 teams, 8 groups of 4, Ro16

                                     simulationOutput = outputWC;
                                }
                                break;
                             case 'euro':
                                 {
                                     let outputEuro = "<h2>EURO Simulation</h2>";
                                     // 1. Run Qualifiers
                                     outputEuro += "<p>Running EURO Qualifiers...</p>";
                                     // Qualify 20 direct + 3 playoff = 23 teams + Host
                                     const euroQualResult = runQualifiers("EURO", 53, 6, 20, 12, 3);
                                     outputEuro += euroQualResult.output;

                                     // 2. Add host nation (e.g., Germany as default)
                                     let euroTeams = [...euroQualResult.qualifiedTeams];
                                     const host = teams.find(t => t.name.includes("Germany")); // Assume Germany hosts
                                     if (host && !euroTeams.some(t => t.name === host.name)) {
                                        euroTeams.push(host);
                                        outputEuro += `<p>Added host nation: ${host.name}</p>`;
                                     } else if (!host) {
                                         outputEuro += `<p>Could not find host nation (Germany). Adding random UEFA team.</p>`;
                                         const potentialHosts = teams.filter(t => t.confederation === 'UEFA' && !euroTeams.includes(t));
                                         if(potentialHosts.length > 0) euroTeams.push(potentialHosts[0]);
                                     }

                                      // Ensure 24 teams total
                                      while (euroTeams.length < 24 && teams.length > euroTeams.length) {
                                          const randomUefaTeam = teams.filter(t => t.confederation === 'UEFA')[Math.floor(Math.random()*teams.filter(t => t.confederation === 'UEFA').length)];
                                          if (!euroTeams.some(t => t.name === randomUefaTeam.name)) euroTeams.push(randomUefaTeam);
                                      }
                                     euroTeams = euroTeams.slice(0, 24);

                                     outputEuro += `<p>Formed final 24 teams for EURO.</p>`;

                                     // 3. Run final tournament
                                     // Check if KAZ is in the final list
                                     const kazInFinals = euroTeams.some(t => t.name === KAZAKHSTAN.name);
                                     outputEuro += runFinalTournament("EURO", euroTeams, 4, 6, 16); // 24 teams, 6 groups of 4, Ro16 (top 2 + 4 best 3rd)

                                     simulationOutput = outputEuro;
                                 }
                                 break;
                            default:
                                simulationOutput = "<p>Selected competition simulation not implemented yet.</p>";
                        }
                    } catch (error) {
                         console.error("Simulation Error:", error);
                         simulationOutput = `<p style="color: red; font-weight: bold;">An error occurred during the simulation: ${error.message}. Check the browser console for details.</p>`;
                    }
                    resultsDiv.innerHTML = simulationOutput; // Display final results
                    startButton.disabled = false; // Re-enable button
                }, 50); // Small delay allows spinner to show
            });
        });

    </script>
</body>
</html>