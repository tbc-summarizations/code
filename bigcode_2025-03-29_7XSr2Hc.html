<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HENRY X PILLOW: The Game.</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            border: 1px solid #fff;
            background-color: #333;
            display: block; /* Prevent extra space below canvas */
        }
        #controls, #gameInfo {
            margin-top: 10px;
            text-align: center;
        }
        button {
            padding: 8px 15px;
            margin: 5px;
            font-size: 1em;
            cursor: pointer;
        }
        #mobile-controls {
            display: none; /* Hidden by default */
            margin-top: 15px;
            user-select: none; /* Prevent text selection */
            width: 100%;
            max-width: 300px; /* Limit width of controls */
        }
        #mobile-controls div {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        #mobile-controls button {
            width: 60px;
            height: 60px;
            font-size: 1.5em;
            border-radius: 50%;
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #attack-button-mobile {
            width: 80px;
            height: 80px;
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
             /* Show mobile controls on smaller screens */
            #mobile-controls {
                display: block;
            }
        }
        .message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.5em;
            z-index: 100;
            display: none; /* Hidden by default */
        }
         .floating-text {
            position: absolute;
            color: red;
            font-weight: bold;
            font-size: 0.8em;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none; /* Prevent interaction */
            z-index: 50;
        }
        @keyframes floatUp {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-30px); }
        }
    </style>
</head>
<body>

    <h1 style="margin-bottom: 5px;">HENRY X PILLOW: The Game.</h1>
    <canvas id="gameCanvas"></canvas>
    <div id="gameInfo">
        <span>Health: <span id="playerHealth">100</span></span> |
        <span>Stage: <span id="stageName">Start Screen</span></span> |
        <span>Invincible: <span id="invincibleStatus">OFF</span></span>
    </div>
    <div id="controls">
        <button id="invincibleBtn">Toggle Invincibility</button>
        <span>Controls: WASD (Move), Space (Attack), Enter (Start)</span>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div>
            <button id="move-up-mobile">W</button>
        </div>
        <div>
            <button id="move-left-mobile">A</button>
            <button style="opacity: 0; pointer-events: none;"></button> <!-- Spacer -->
            <button id="move-right-mobile">D</button>
        </div>
        <div>
            <button id="move-down-mobile">S</button>
        </div>
         <div>
             <button id="attack-button-mobile">ðŸ’¥</button>
         </div>
    </div>

    <div id="messageOverlay" class="message-overlay">Press ENTER to Start</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerHealthDisplay = document.getElementById('playerHealth');
        const stageNameDisplay = document.getElementById('stageName');
        const invincibleStatusDisplay = document.getElementById('invincibleStatus');
        const invincibleBtn = document.getElementById('invincibleBtn');
        const messageOverlay = document.getElementById('messageOverlay');

        // Game Settings
        let canvasWidth = Math.min(window.innerWidth * 0.9, 800);
        let canvasHeight = Math.min(window.innerHeight * 0.6, 600);
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        let gameStarted = false;
        let gameOver = false;
        let gameWon = false;
        let isInvincible = false;
        let currentStage = 0; // 0: Start, 1: Clyde Intro, 2: Clyde Fight, 3: Roaming 1, 4: Meeth Fight ...
        let keys = {};
        let projectiles = [];
        let enemies = [];
        let cannons = []; // Football cannons
        let floatingTexts = [];

        const STAGES = [
            { name: "Start Screen", type: "start" },
            { name: "Clyde Intro", type: "dialogue", lines: ["Henry: Clyde, I want to cuddle pillow.", "Clyde: Henry, No! That's not a good idea!", "Henry: I don't care, Clyde. I'm going to do it.", "Clyde: I won't let you!", "(Press Enter to fight Clyde)"] },
            { name: "Tutorial: Clyde", type: "boss", bossId: "clyde", nextStage: 3 },
            { name: "Roaming Clydes 1", type: "roaming", enemyType: "clyde_part", enemyCount: 5, nextStage: 5 },
            { name: "Dialogue Pre-Meeth", type: "dialogue", lines: ["You defeated Clyde, but parts of him linger...", "Now, face your best friend...", "(Press Enter to fight Meeththexep)"] },
            { name: "Boss: Meeththexep", type: "boss", bossId: "meeth", nextStage: 6 },
            { name: "Roaming Clydes 2", type: "roaming", enemyType: "clyde_part", enemyCount: 7, nextStage: 8 },
            { name: "Dialogue Pre-SC0J", type: "dialogue", lines: ["Meeth was tough... but the path continues.", "An unknown BFCS member blocks the way.", "(Press Enter to fight SC0J)"] },
            { name: "Boss: SC0J", type: "boss", bossId: "sc0j", nextStage: 9 },
            { name: "Roaming Clydes 3", type: "roaming", enemyType: "clyde_part", enemyCount: 8, nextStage: 11 }, // Clydes get tougher now
            { name: "Dialogue Pre-Frank", type: "dialogue", lines: ["SC0J barely fought... He seemed hesitant.", "'Maybe cuddling pillow isn't so bad?' you think.", "Clyde's parts nearby seem to shudder...", "Another challenger appears!", "(Press Enter to fight Frank)"] },
            { name: "Boss: Frank", type: "boss", bossId: "frank", nextStage: 12 },
            { name: "Roaming Clydes 4", type: "roaming", enemyType: "clyde_part", enemyCount: 10, nextStage: 14 },
            { name: "Dialogue Pre-Admiral", type: "dialogue", lines: ["Frank was... interesting.", "Prepare for a fan of the beautiful game!", "(Press Enter to fight Admiral)"] },
            { name: "Boss: Admiral", type: "boss", bossId: "admiral", nextStage: 15 },
            { name: "Hazard Zone 1: Football Cannons", type: "roaming", enemyType: "clyde_part", enemyCount: 5, hazard: "cannons", cannonCount: 4, nextStage: 17 },
            { name: "Dialogue Pre-BDYT", type: "dialogue", lines: ["Those cannons were annoying!", "Beware the Siren Enthusiast!", "(Press Enter to fight BDYT)"] },
            { name: "Boss: BDYT", type: "boss", bossId: "bdyt", nextStage: 18 },
            { name: "Roaming Clydes 5", type: "roaming", enemyType: "clyde_part", enemyCount: 12, hazard: "cannons", cannonCount: 2, nextStage: 20 },
            { name: "Dialogue Pre-Memo", type: "dialogue", lines: ["BDYT's noise is gone.", "Who is Memo?", "(Press Enter to fight Memo)"] },
            { name: "Boss: Memo", type: "boss", bossId: "memo", nextStage: 21 },
            { name: "Roaming Clydes 6", type: "roaming", enemyType: "clyde_part", enemyCount: 10, hazard: "cannons", cannonCount: 3, nextStage: 23 },
            { name: "Dialogue Pre-Adam", type: "dialogue", lines: ["Memo was... brief?", "A programmer stands in your way!", "(Press Enter to fight Adam)"] },
            { name: "Boss: Adam", type: "boss", bossId: "adam", nextStage: 24 },
            { name: "Roaming Clydes 7", type: "roaming", enemyType: "clyde_part", enemyCount: 13, hazard: "cannons", cannonCount: 4, nextStage: 26 },
            { name: "Dialogue Pre-HappyMan", type: "dialogue", lines: ["Adam's code couldn't stop you.", "Face the Strongest Chicken!", "(Press Enter to fight HappyMan)"] },
            { name: "Boss: HappyMan", type: "boss", bossId: "happyman", nextStage: 27 },
            { name: "Roaming Clydes 8", type: "roaming", enemyType: "clyde_part", enemyCount: 15, hazard: "cannons", cannonCount: 5, nextStage: 29 },
             { name: "Dialogue Pre-Alan", type: "dialogue", lines: ["That chicken packed a punch!", "Who's next? Alan?", "(Press Enter to fight Alan)"] },
            { name: "Boss: Alan", type: "boss", bossId: "alan", nextStage: 30 },
            { name: "Roaming Clydes 9", type: "roaming", enemyType: "clyde_part", enemyCount: 12, hazard: "cannons", cannonCount: 6, nextStage: 32 },
            { name: "Dialogue Pre-Dekoder", type: "dialogue", lines: ["Alan is down.", "A Half-Life fan approaches!", "(Press Enter to fight Dekoder)"] },
            { name: "Boss: Dekoder", type: "boss", bossId: "dekoder", nextStage: 33 },
            { name: "Roaming Clydes 10", type: "roaming", enemyType: "clyde_part", enemyCount: 16, hazard: "cannons", cannonCount: 7, nextStage: 35 },
            { name: "Dialogue Pre-Nagg", type: "dialogue", lines: ["Dekoder has fallen.", "Prepare for maximum annoyance!", "(Press Enter to fight Nagg)"] },
            { name: "Boss: Nagg", type: "boss", bossId: "nagg", nextStage: 36 },
             { name: "Roaming Clydes 11", type: "roaming", enemyType: "clyde_part", enemyCount: 18, hazard: "cannons", cannonCount: 8, nextStage: 38 },
            { name: "Dialogue Pre-Uami", type: "dialogue", lines: ["Nagg was... nagging.", "The BFCS Host appears! Your own creation!", "(Press Enter to fight Uami Bosim)"] },
            { name: "Boss: Uami Bosim", type: "boss", bossId: "uami", nextStage: 39 },
            { name: "Dialogue Pre-Final", type: "dialogue", lines: ["Uami Bosim... defeated.", "You're almost there... Pillow is close!", "But wait... who is this?", "Kamran: Henry! Stop!", "(Press Enter for the Final Battle)"] },
            { name: "Final Boss: KAMRAN", type: "boss", bossId: "kamran", nextStage: 40 },
            { name: "Game Won", type: "end", message: "You reached Pillow... but at what cost?\nGAME OVER...?" }
        ];

        let dialogueState = {
            currentLine: 0,
            lines: []
        };

        // Player Setup
        const player = {
            x: canvasWidth / 2,
            y: canvasHeight - 60,
            width: 30,
            height: 40,
            color: 'blue',
            emoji: 'ðŸ˜Š', // Henry
            speed: 4,
            health: 100,
            maxHealth: 100,
            attackCooldown: 0,
            attackDelay: 30, // Frames between attacks
            isAttacking: false,
            attackFrame: 0,
            attackDuration: 10 // Frames the attack visualization lasts
        };

        // Boss Definitions
        const bossTemplates = {
            clyde: { name: "Clyde", emoji: 'ðŸ˜ ', width: 50, height: 50, health: 100, speed: 1.5, attacks: [{ type: 'charge', cooldown: 120, duration: 30 }], color: 'red', resistance: 0 },
            meeth: { name: "Meeththexep", emoji: 'ðŸ˜Ž', width: 45, height: 45, health: 150, speed: 2, attacks: [{ type: 'shoot', cooldown: 90, projectileSpeed: 4, projectileSize: 8 }], color: 'purple' },
            sc0j: { name: "SC0J", emoji: 'ðŸ¤”', width: 40, height: 40, health: 80, speed: 1, attacks: [{ type: 'hesitate', cooldown: 180 }], color: 'grey', weak: true }, // Weak fight
            frank: { name: "Frank", emoji: 'â“', width: 50, height: 50, health: 200, speed: 1.8, attacks: [{ type: 'random_move', cooldown: 60 }, { type: 'shoot', cooldown: 100, projectileSpeed: 5, projectileSize: 10 }], color: 'brown' },
            admiral: { name: "Admiral", emoji: 'âš½', width: 55, height: 55, health: 250, speed: 2.2, attacks: [{ type: 'kick', cooldown: 80, projectileSpeed: 7, projectileSize: 15 }], color: 'darkgreen' },
            bdyt: { name: "BDYT", emoji: 'ðŸš¨', width: 40, height: 60, health: 220, speed: 2.5, attacks: [{ type: 'siren_wave', cooldown: 150, duration: 90, range: 100 }], color: 'darkred' },
            memo: { name: "Memo", emoji: 'ðŸ“', width: 35, height: 35, health: 180, speed: 3, attacks: [{ type: 'dash', cooldown: 70 }], color: 'lightblue' },
            adam: { name: "Adam", emoji: 'ðŸ’»', width: 40, height: 40, health: 280, speed: 1.5, attacks: [{ type: 'code_wall', cooldown: 200, duration: 120 }, { type: 'bug_shot', cooldown: 100, projectileSpeed: 4, projectileSize: 5 }], color: 'silver' },
            happyman: { name: "HappyMan", emoji: 'ðŸ”ðŸ’ª', width: 60, height: 60, health: 350, speed: 2.8, attacks: [{ type: 'peck_charge', cooldown: 90 }, { type: 'egg_bomb', cooldown: 120, projectileSpeed: 3, projectileSize: 20, splash: 30 }], color: 'yellow' },
            alan: { name: "Alan", emoji: 'ðŸ‘½', width: 45, height: 45, health: 300, speed: 2, attacks: [{ type: 'teleport_shoot', cooldown: 110, projectileSpeed: 6, projectileSize: 8 }], color: 'lightgreen' },
            dekoder: { name: "Dekoder", emoji: 'ðŸ”§', width: 50, height: 50, health: 320, speed: 1.9, attacks: [{ type: 'crowbar_swing', cooldown: 75, range: 40 }, { type: 'hev_shot', cooldown: 130, projectileSpeed: 8, projectileSize: 12 }], color: 'orange' },
            nagg: { name: "Nagg", emoji: 'ðŸ—£ï¸', width: 40, height: 40, health: 250, speed: 3.5, attacks: [{ type: 'annoy_spam', cooldown: 40, projectileSpeed: 5, projectileSize: 4, count: 3 }], color: 'pink' },
            uami: { name: "Uami Bosim", emoji: 'ðŸ¤–', width: 65, height: 65, health: 400, speed: 2.3, attacks: [{ type: 'multi_shot', cooldown: 100, projectileSpeed: 6, projectileSize: 7, count: 5 }, { type: 'laser_beam', cooldown: 180, duration: 60 }], color: 'cyan' },
            kamran: { name: "KAMRAN", emoji: 'ðŸ›¡ï¸', width: 60, height: 60, health: 500, speed: 2.5, attacks: [{ type: 'savior_charge', cooldown: 120 }, { type: 'friend_beam', cooldown: 150, duration: 70 }, { type: 'block', cooldown: 90, duration: 40 }], color: 'gold' },
        };

        // Enemy Definitions
        const enemyTemplates = {
            clyde_part: { emoji: 'ðŸ’¢', width: 25, height: 25, health: 20, speed: 1.2, points: 10, color: 'darkred', resistance: 0 }
        };

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (!gameStarted && !gameOver && e.code === 'Enter') {
                if (STAGES[currentStage].type === 'start' || STAGES[currentStage].type === 'dialogue') {
                    advanceDialogueOrStage();
                }
            }
            if (gameStarted && !gameOver && e.code === 'Space' && player.attackCooldown <= 0) {
                playerAttack();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // --- Mobile Input Handling ---
        const setupMobileButton = (id, action) => {
            const button = document.getElementById(id);
            if (button) {
                 let intervalId = null;
                 button.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent zoom/scroll
                    action(true); // Start action
                    // Special handling for movement buttons to allow holding
                    if (id.startsWith('move')) {
                        intervalId = setInterval(() => action(true), 50); // Repeat action while held
                    }
                 }, { passive: false });
                 button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    action(false); // Stop action
                    if (intervalId) {
                         clearInterval(intervalId);
                         intervalId = null;
                    }
                 });
                 button.addEventListener('touchcancel', (e) => { // Handle interruption
                     e.preventDefault();
                     action(false);
                     if (intervalId) {
                         clearInterval(intervalId);
                         intervalId = null;
                     }
                 });
            }
        };

        setupMobileButton('move-up-mobile', (pressed) => keys['KeyW'] = pressed);
        setupMobileButton('move-down-mobile', (pressed) => keys['KeyS'] = pressed);
        setupMobileButton('move-left-mobile', (pressed) => keys['KeyA'] = pressed);
        setupMobileButton('move-right-mobile', (pressed) => keys['KeyD'] = pressed);
        setupMobileButton('attack-button-mobile', (pressed) => {
            if (pressed && gameStarted && !gameOver && player.attackCooldown <= 0) {
                 playerAttack();
            }
            // No need for key['Space'] = pressed for attack, it's event-driven
        });


        // --- Invincibility ---
        invincibleBtn.addEventListener('click', () => {
            isInvincible = !isInvincible;
            invincibleStatusDisplay.textContent = isInvincible ? 'ON' : 'OFF';
            console.log(`Invincibility: ${isInvincible}`);
        });

        // --- Game Logic Functions ---
        function startGame() {
            gameStarted = true;
            gameOver = false;
            gameWon = false;
            player.health = player.maxHealth;
            player.x = canvasWidth / 2;
            player.y = canvasHeight - 60;
            currentStage = 0; // Start from the beginning
            advanceDialogueOrStage(); // Move to first actual stage
            requestAnimationFrame(gameLoop);
        }

        function advanceDialogueOrStage() {
            const stage = STAGES[currentStage];

            if (stage.type === 'dialogue') {
                dialogueState.lines = stage.lines;
                if (dialogueState.currentLine < dialogueState.lines.length) {
                    messageOverlay.textContent = dialogueState.lines[dialogueState.currentLine];
                    messageOverlay.style.display = 'block';
                    dialogueState.currentLine++;
                    return; // Wait for next Enter press
                } else {
                    // Dialogue finished, proceed to next stage
                    dialogueState.currentLine = 0;
                    dialogueState.lines = [];
                    messageOverlay.style.display = 'none';
                    currentStage++; // Move index to the actual action stage
                }
            } else if (stage.type === 'start') {
                 currentStage++; // Move past start screen
            }
             else {
                // If it wasn't a dialogue or start screen we were waiting on, just move to the next index
                currentStage = stage.nextStage !== undefined ? stage.nextStage : currentStage + 1;
            }


            if (currentStage >= STAGES.length) {
                console.error("Attempted to advance past the last stage!");
                endGame(true); // Or handle game completion appropriately
                return;
            }

            const nextStageData = STAGES[currentStage];
            stageNameDisplay.textContent = nextStageData.name;
            console.log(`Entering Stage: ${nextStageData.name}`);

             // Clear previous stage elements
             enemies = [];
             projectiles = [];
             cannons = [];
             floatingTexts = [];

             // Setup new stage
            if (nextStageData.type === 'dialogue') {
                dialogueState.currentLine = 0; // Reset for new dialogue
                advanceDialogueOrStage(); // Immediately show the first line
            } else if (nextStageData.type === 'boss') {
                 spawnBoss(nextStageData.bossId);
                 // Specific logic adjustments based on boss defeated
                 if (nextStageData.bossId === 'sc0j') {
                     // Increase Clyde resistance after SC0J fight is *initiated* (dialogue ends)
                     enemyTemplates.clyde_part.resistance = 0.25; // Example: 25% resistance
                     console.log("Clyde parts resistance increased!");
                 }
            } else if (nextStageData.type === 'roaming') {
                 spawnEnemies(nextStageData.enemyType, nextStageData.enemyCount);
                 if (nextStageData.hazard === 'cannons') {
                     spawnCannons(nextStageData.cannonCount);
                     // Activate cannons after Admiral is *defeated* and roaming starts
                 }
            } else if (nextStageData.type === 'end') {
                 endGame(true, nextStageData.message);
            } else if (nextStageData.type === 'start') {
                 messageOverlay.textContent = "Press ENTER to Start";
                 messageOverlay.style.display = 'block';
            }
        }


        function playerAttack() {
            player.attackCooldown = player.attackDelay;
            player.isAttacking = true;
            player.attackFrame = player.attackDuration;

            // Create a hitbox or projectile for the attack
            // Simple melee hitbox in front of player for now
            const attackHitbox = {
                x: player.x - 5, // Slightly wider than player
                y: player.y - player.height / 2,
                width: player.width + 10,
                height: player.height / 2,
                type: 'player_melee',
                damage: 10 // Base damage
            };

            // Check for collision with enemies immediately
             checkAttackCollision(attackHitbox);
        }

        function checkAttackCollision(attackHitbox) {
            enemies.forEach((enemy, index) => {
                 if (checkCollision(attackHitbox, enemy)) {
                     let damage = attackHitbox.damage;
                     let message = `${damage}`;
                     let hitMessage = "";

                     // Special "Benchod Gun" logic for Clyde parts
                     if (enemy.templateId === 'clyde_part') {
                         damage = 999; // Insta-kill
                         hitMessage = "Benchod";
                         // Apply resistance
                         damage *= (1 - enemy.resistance);
                         damage = Math.round(damage);
                         message = hitMessage; // Override damage number with message
                     }

                     enemy.health -= damage;
                     addFloatingText(message, enemy.x + enemy.width / 2, enemy.y, hitMessage ? 'lime' : 'red'); // Green for special hit

                     if (enemy.health <= 0) {
                         // Add score, effects, etc.
                         enemies.splice(index, 1);
                         // Check if stage clear condition met
                         if (STAGES[currentStage].type === 'roaming' || STAGES[currentStage].type === 'boss') {
                             if (enemies.length === 0) {
                                 console.log("Stage Cleared!");
                                 advanceDialogueOrStage();
                             }
                         }
                     }
                 }
             });
        }

        function spawnBoss(bossId) {
            const template = bossTemplates[bossId];
            if (!template) {
                console.error(`Boss template not found: ${bossId}`);
                return;
            }
            enemies.push({
                x: canvasWidth / 2 - template.width / 2,
                y: 50,
                width: template.width,
                height: template.height,
                health: template.health,
                maxHealth: template.health,
                speed: template.speed,
                color: template.color,
                emoji: template.emoji,
                isBoss: true,
                id: bossId,
                attacks: template.attacks.map(a => ({ ...a, currentCooldown: Math.random() * a.cooldown })), // Copy attacks and add cooldown state
                attackState: {}, // For tracking ongoing attacks like charges
                resistance: template.resistance || 0,
                 weak: template.weak || false,
                 templateId: bossId // Keep track of original template for logic
            });
        }

        function spawnEnemies(enemyType, count) {
            const template = enemyTemplates[enemyType];
            if (!template) {
                console.error(`Enemy template not found: ${enemyType}`);
                return;
            }
            for (let i = 0; i < count; i++) {
                enemies.push({
                    x: Math.random() * (canvasWidth - template.width),
                    y: Math.random() * (canvasHeight / 2 - template.height), // Spawn in top half
                    width: template.width,
                    height: template.height,
                    health: template.health,
                    maxHealth: template.health,
                    speed: template.speed,
                    color: template.color,
                    emoji: template.emoji,
                    isBoss: false,
                    id: `${enemyType}_${i}`,
                    resistance: template.resistance || 0, // Use current resistance from template
                    templateId: enemyType // Keep track of original template for logic
                });
            }
        }

         function spawnCannons(count) {
             const cannonWidth = 30;
             const cannonHeight = 30;
             for (let i = 0; i < count; i++) {
                 const side = Math.random() < 0.5 ? 'left' : 'right';
                 cannons.push({
                     x: side === 'left' ? 0 : canvasWidth - cannonWidth,
                     y: Math.random() * (canvasHeight - 100) + 50, // Avoid very top/bottom
                     width: cannonWidth,
                     height: cannonHeight,
                     color: 'grey',
                     emoji: 'âš½',
                     cooldown: 180 + Math.random() * 60, // Time between shots (3-4 seconds)
                     timer: Math.random() * 180, // Initial timer offset
                     projectileSpeed: 5,
                     projectileSize: 15,
                     direction: side === 'left' ? 1 : -1 // 1 for right, -1 for left
                 });
             }
         }

        function updatePlayer() {
            if (gameOver || !gameStarted) return;

            // Movement
            let dx = 0;
            let dy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;

             // Normalize diagonal movement
             if (dx !== 0 && dy !== 0) {
                 const magnitude = Math.sqrt(dx*dx + dy*dy);
                 dx = (dx / magnitude);
                 dy = (dy / magnitude);
             }

            player.x += dx * player.speed;
            player.y += dy * player.speed;


            // Keep player within bounds
            player.x = Math.max(0, Math.min(canvasWidth - player.width, player.x));
            player.y = Math.max(0, Math.min(canvasHeight - player.height, player.y));

            // Attack cooldown
            if (player.attackCooldown > 0) {
                player.attackCooldown--;
            }
            // Attack animation
            if (player.isAttacking) {
                player.attackFrame--;
                if (player.attackFrame <= 0) {
                    player.isAttacking = false;
                }
            }
        }

        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                // Basic AI: Move towards player
                const dx = player.x + player.width / 2 - (enemy.x + enemy.width / 2);
                const dy = player.y + player.height / 2 - (enemy.y + enemy.height / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                 if (dist > 1) { // Prevent division by zero and jittering
                     enemy.x += (dx / dist) * enemy.speed;
                     enemy.y += (dy / dist) * enemy.speed;
                 }

                 // Boss specific AI / Attacks
                 if (enemy.isBoss && enemy.attacks) {
                     enemy.attacks.forEach(attack => {
                         attack.currentCooldown -= 1;
                         if (attack.currentCooldown <= 0) {
                             executeBossAttack(enemy, attack);
                             attack.currentCooldown = attack.cooldown * (enemy.weak ? 1.5 : 1); // Reset cooldown (longer if weak)
                         }
                     });
                 }

                // Simple collision with player (damage player)
                if (checkCollision(player, enemy)) {
                    handlePlayerDamage(enemy.isBoss ? 15 : 5); // More damage from bosses
                }
            });
        }

        function executeBossAttack(boss, attack) {
            console.log(`${boss.name} uses ${attack.type}`);
             const targetX = player.x + player.width / 2;
             const targetY = player.y + player.height / 2;
             const bossCenterX = boss.x + boss.width / 2;
             const bossCenterY = boss.y + boss.height / 2;

             switch (attack.type) {
                 case 'charge':
                     // Simple charge - store target direction
                     const dx_c = targetX - bossCenterX;
                     const dy_c = targetY - bossCenterY;
                     const dist_c = Math.sqrt(dx_c * dx_c + dy_c * dy_c);
                     boss.attackState.chargeDir = { x: dx_c / dist_c, y: dy_c / dist_c };
                     boss.attackState.chargeTimer = attack.duration;
                     boss.speed *= 2; // Temporarily increase speed
                     break;
                 case 'shoot':
                 case 'kick': // Treat kick as shoot for simplicity
                 case 'bug_shot':
                 case 'hev_shot':
                     const dx_s = targetX - bossCenterX;
                     const dy_s = targetY - bossCenterY;
                     const dist_s = Math.sqrt(dx_s * dx_s + dy_s * dy_s);
                     projectiles.push({
                         x: bossCenterX, y: bossCenterY,
                         width: attack.projectileSize, height: attack.projectileSize,
                         color: boss.color, emoji: attack.type === 'kick' ? 'âš½' : 'ðŸ’¥',
                         speed: attack.projectileSpeed,
                         vx: (dx_s / dist_s) * attack.projectileSpeed,
                         vy: (dy_s / dist_s) * attack.projectileSpeed,
                         damage: attack.type === 'kick' ? 20 : (attack.type === 'hev_shot' ? 25 : 15),
                         owner: 'enemy'
                     });
                     break;
                 case 'hesitate': // SC0J specific - does nothing
                    addFloatingText("...", boss.x + boss.width / 2, boss.y, 'white');
                    break;
                 case 'random_move': // Frank
                    boss.x += (Math.random() - 0.5) * 100;
                    boss.y += (Math.random() - 0.5) * 100;
                    boss.x = Math.max(0, Math.min(canvasWidth - boss.width, boss.x));
                    boss.y = Math.max(0, Math.min(canvasHeight - boss.height, boss.y));
                    break;
                case 'siren_wave': // BDYT - creates temporary damage zone around boss
                     projectiles.push({
                         x: bossCenterX, y: bossCenterY, radius: 10, maxRadius: attack.range,
                         color: 'rgba(255, 0, 0, 0.3)', emoji: 'ðŸ”Š', duration: attack.duration, timer: 0,
                         damage: 5, owner: 'enemy_aoe', type: 'expanding_wave'
                     });
                     break;
                 case 'dash': // Memo
                     const dx_d = targetX - bossCenterX;
                     const dy_d = targetY - bossCenterY;
                     const dist_d = Math.sqrt(dx_d * dx_d + dy_d * dy_d);
                     boss.attackState.dashDir = { x: dx_d / dist_d, y: dy_d / dist_d };
                     boss.attackState.dashTimer = 20; // Short dash duration
                     boss.speed *= 3;
                     break;
                 case 'code_wall': // Adam - Creates temporary blocking/damaging objects? Simplified: slow field
                      projectiles.push({
                          x: Math.random() * canvasWidth, y: Math.random() * canvasHeight,
                          width: 100, height: 100, color: 'rgba(0, 255, 0, 0.2)', emoji: 'ðŸ§±',
                          duration: attack.duration, timer: 0, damage: 1, owner: 'enemy_aoe', type: 'slow_field'
                      });
                      break;
                 case 'egg_bomb': // HappyMan
                     projectiles.push({
                         x: bossCenterX, y: bossCenterY,
                         width: attack.projectileSize, height: attack.projectileSize,
                         color: 'white', emoji: 'ðŸ¥š', speed: attack.projectileSpeed,
                         vx: (Math.random() - 0.5) * attack.projectileSpeed, // Less accurate throw
                         vy: -attack.projectileSpeed, // Throws upwards slightly
                         damage: 20, owner: 'enemy', type: 'bomb', splashRange: attack.splash, explodeTimer: 90 // Explodes after 1.5s
                     });
                     break;
                 case 'peck_charge': // HappyMan
                     const dx_p = targetX - bossCenterX;
                     const dy_p = targetY - bossCenterY;
                     const dist_p = Math.sqrt(dx_p * dx_p + dy_p * dy_p);
                     boss.attackState.chargeDir = { x: dx_p / dist_p, y: dy_p / dist_p };
                     boss.attackState.chargeTimer = 40;
                     boss.speed *= 2.5;
                     break;
                 case 'teleport_shoot': // Alan
                     boss.x = Math.random() * (canvasWidth - boss.width);
                     boss.y = Math.random() * (canvasHeight / 2 - boss.height); // Teleport top half
                     // Shoot immediately after teleport
                     const dx_ts = targetX - (boss.x + boss.width / 2);
                     const dy_ts = targetY - (boss.y + boss.height / 2);
                     const dist_ts = Math.sqrt(dx_ts * dx_ts + dy_ts * dy_ts);
                      projectiles.push({
                          x: boss.x + boss.width / 2, y: boss.y + boss.height / 2,
                          width: attack.projectileSize, height: attack.projectileSize,
                          color: boss.color, emoji: 'âœ¨',
                          speed: attack.projectileSpeed,
                          vx: (dx_ts / dist_ts) * attack.projectileSpeed,
                          vy: (dy_ts / dist_ts) * attack.projectileSpeed,
                          damage: 18, owner: 'enemy'
                      });
                      break;
                  case 'crowbar_swing': // Dekoder - Melee attack
                      // Check if player is in range
                      const dist_cs = Math.sqrt(Math.pow(targetX - bossCenterX, 2) + Math.pow(targetY - bossCenterY, 2));
                      if (dist_cs < attack.range) {
                           handlePlayerDamage(25);
                           addFloatingText("Clang!", player.x + player.width/2, player.y, 'orange');
                      }
                      break;
                 case 'annoy_spam': // Nagg
                      for (let i = 0; i < attack.count; i++) {
                          const angle = Math.atan2(targetY - bossCenterY, targetX - bossCenterX) + (Math.random() - 0.5) * 0.5; // Add spread
                          projectiles.push({
                              x: bossCenterX, y: bossCenterY,
                              width: attack.projectileSize, height: attack.projectileSize,
                              color: boss.color, emoji: 'ðŸ’¢',
                              speed: attack.projectileSpeed,
                              vx: Math.cos(angle) * attack.projectileSpeed,
                              vy: Math.sin(angle) * attack.projectileSpeed,
                              damage: 5, owner: 'enemy'
                          });
                      }
                      break;
                case 'multi_shot': // Uami
                     const baseAngle = Math.atan2(targetY - bossCenterY, targetX - bossCenterX);
                     const spread = 0.6; // Radians for spread
                     for (let i = 0; i < attack.count; i++) {
                         const angle = baseAngle - spread / 2 + (spread / (attack.count - 1)) * i;
                         projectiles.push({
                             x: bossCenterX, y: bossCenterY,
                             width: attack.projectileSize, height: attack.projectileSize,
                             color: boss.color, emoji: 'ðŸ”©',
                             speed: attack.projectileSpeed,
                             vx: Math.cos(angle) * attack.projectileSpeed,
                             vy: Math.sin(angle) * attack.projectileSpeed,
                             damage: 15, owner: 'enemy'
                         });
                     }
                     break;
                case 'laser_beam': // Uami / Kamran (friend_beam)
                     projectiles.push({
                         x: bossCenterX, y: bossCenterY, targetX: targetX, targetY: targetY,
                         width: 10, color: attack.type === 'friend_beam' ? 'rgba(255, 215, 0, 0.7)' : 'rgba(255, 0, 255, 0.7)',
                         emoji: 'âš¡', duration: attack.duration, timer: 0, damage: 3, // Damage per frame? High risk
                         owner: 'enemy_beam', type: 'beam'
                     });
                     break;
                 case 'savior_charge': // Kamran
                     const dx_sc = targetX - bossCenterX;
                     const dy_sc = targetY - bossCenterY;
                     const dist_sc = Math.sqrt(dx_sc * dx_sc + dy_sc * dy_sc);
                     boss.attackState.chargeDir = { x: dx_sc / dist_sc, y: dy_sc / dist_sc };
                     boss.attackState.chargeTimer = 50;
                     boss.speed *= 2.8;
                     break;
                 case 'block': // Kamran
                     boss.attackState.blocking = true;
                     boss.attackState.blockTimer = attack.duration;
                     boss.speed = 0; // Stop moving while blocking
                     break;
             }
        }


        function updateBossState() {
             enemies.filter(e => e.isBoss).forEach(boss => {
                 // Handle ongoing attack states
                 if (boss.attackState.chargeTimer > 0) {
                     boss.x += boss.attackState.chargeDir.x * boss.speed;
                     boss.y += boss.attackState.chargeDir.y * boss.speed;
                     boss.attackState.chargeTimer--;
                     if (boss.attackState.chargeTimer <= 0) {
                         boss.speed /= (boss.id === 'happyman' ? 2.5 : (boss.id === 'clyde' ? 2 : (boss.id === 'kamran' ? 2.8 : 1))); // Restore speed correctly
                         delete boss.attackState.chargeDir;
                     }
                 }
                 if (boss.attackState.dashTimer > 0) {
                      boss.x += boss.attackState.dashDir.x * boss.speed;
                      boss.y += boss.attackState.dashDir.y * boss.speed;
                      boss.attackState.dashTimer--;
                      if (boss.attackState.dashTimer <= 0) {
                          boss.speed /= 3; // Restore speed
                          delete boss.attackState.dashDir;
                      }
                  }
                 if (boss.attackState.blocking) {
                      boss.attackState.blockTimer--;
                      if (boss.attackState.blockTimer <= 0) {
                          boss.attackState.blocking = false;
                          boss.speed = bossTemplates[boss.id].speed; // Restore original speed
                      }
                  }

                  // Keep boss in bounds
                  boss.x = Math.max(0, Math.min(canvasWidth - boss.width, boss.x));
                  boss.y = Math.max(0, Math.min(canvasHeight - boss.height, boss.y));
             });
        }


        function updateProjectiles() {
            projectiles.forEach((p, index) => {
                 if (p.type === 'expanding_wave') {
                     p.radius += 2; // Expansion speed
                     p.timer++;
                     if (p.timer >= p.duration || p.radius >= p.maxRadius) {
                         projectiles.splice(index, 1);
                         return;
                     }
                     // Check collision for AoE
                     const distToPlayer = Math.sqrt(Math.pow(player.x + player.width / 2 - p.x, 2) + Math.pow(player.y + player.height / 2 - p.y, 2));
                     if (distToPlayer < p.radius) {
                          handlePlayerDamage(p.damage); // Small continuous damage
                     }
                 } else if (p.type === 'beam') {
                     p.timer++;
                     if (p.timer >= p.duration) {
                         projectiles.splice(index, 1);
                         return;
                     }
                     // Check collision along the beam line (simplified: check player intersection with line segment)
                     // Very basic check: If player center is close to the line segment
                     if (isPlayerOnBeam(p.x, p.y, p.targetX, p.targetY, player)) {
                          handlePlayerDamage(p.damage);
                     }

                 } else if (p.type === 'bomb') {
                     p.x += p.vx;
                     p.y += p.vy;
                     p.vy += 0.1; // Gravity effect
                     p.explodeTimer--;
                     if (p.explodeTimer <= 0) {
                         // Explode! Create splash damage area
                          addFloatingText("Boom!", p.x, p.y, 'orange');
                          const splashHitbox = { x: p.x - p.splashRange, y: p.y - p.splashRange, width: p.splashRange * 2, height: p.splashRange * 2 };
                          if(checkCollision(player, splashHitbox)) {
                              handlePlayerDamage(30); // Splash damage
                          }
                         projectiles.splice(index, 1);
                         return;
                     }
                      // Bounce off floor?
                      if (p.y > canvasHeight - p.height) {
                           p.y = canvasHeight - p.height;
                           p.vy *= -0.5; // Dampen bounce
                      }

                 } else if (p.type === 'slow_field') {
                     p.timer++;
                     if (p.timer >= p.duration) {
                         projectiles.splice(index, 1);
                         return;
                     }
                      // Check collision and apply slow (handled in player update or here?)
                      // Simple check here:
                      if(checkCollision(player, p)) {
                          // Apply slow effect - maybe directly modify player speed temporarily? Difficult to manage state.
                          // Alternative: Do small damage instead of slow
                           handlePlayerDamage(p.damage);
                      }

                 } else { // Normal projectiles
                     p.x += p.vx;
                     p.y += p.vy;

                     // Remove projectiles going off-screen
                     if (p.x < 0 || p.x > canvasWidth || p.y < 0 || p.y > canvasHeight) {
                         projectiles.splice(index, 1);
                         return;
                     }

                     // Check collision with player
                     if (p.owner === 'enemy' && checkCollision(player, p)) {
                         handlePlayerDamage(p.damage);
                         projectiles.splice(index, 1);
                         return;
                     }
                 }

            });
        }

        function isPlayerOnBeam(x1, y1, x2, y2, playerRect) {
             // Basic check: distance from player center to the line segment
             const px = playerRect.x + playerRect.width / 2;
             const py = playerRect.y + playerRect.height / 2;
             const beamLengthSq = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
             if (beamLengthSq === 0) return false; // Avoid division by zero

             let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / beamLengthSq;
             t = Math.max(0, Math.min(1, t)); // Clamp t to the segment

             const closestX = x1 + t * (x2 - x1);
             const closestY = y1 + t * (y2 - y1);

             const distX = px - closestX;
             const distY = py - closestY;
             const distanceSq = distX * distX + distY * distY;

             const hitThreshold = Math.pow(playerRect.width / 2 + 5, 2); // Player radius + beam width allowance

             return distanceSq < hitThreshold;
         }

        function updateCannons() {
             cannons.forEach(cannon => {
                 cannon.timer++;
                 if (cannon.timer >= cannon.cooldown) {
                     cannon.timer = 0;
                     // Fire projectile
                      projectiles.push({
                          x: cannon.x + cannon.width / 2,
                          y: cannon.y + cannon.height / 2,
                          width: cannon.projectileSize,
                          height: cannon.projectileSize,
                          color: 'black',
                          emoji: 'âš½',
                          speed: cannon.projectileSpeed,
                          vx: cannon.direction * cannon.projectileSpeed,
                          vy: 0,
                          damage: 25, // Cannon balls hurt!
                          owner: 'enemy' // Treat as enemy projectile
                      });
                 }
             });
        }

        function updateFloatingTexts() {
            floatingTexts.forEach((text, index) => {
                text.y -= 1; // Move up
                text.opacity -= 0.02;
                if (text.opacity <= 0) {
                    floatingTexts.splice(index, 1);
                }
            });
        }

        function addFloatingText(text, x, y, color = 'red') {
            const id = `floating-text-${Date.now()}-${Math.random()}`;
            floatingTexts.push({ id, text, x, y, color, opacity: 1 });

             // Create the HTML element for rendering
             const textElement = document.createElement('div');
             textElement.id = id;
             textElement.className = 'floating-text';
             textElement.style.left = `${x}px`;
             textElement.style.top = `${y}px`;
             textElement.style.color = color;
             textElement.textContent = text;
             document.body.appendChild(textElement);

             // Remove the HTML element after animation
             setTimeout(() => {
                 const element = document.getElementById(id);
                 if (element) {
                     element.remove();
                 }
                 // Also remove from our internal tracking array if it wasn't removed by updateFloatingTexts yet
                 const idx = floatingTexts.findIndex(ft => ft.id === id);
                 if (idx !== -1) floatingTexts.splice(idx, 1);
             }, 1000); // Match animation duration
         }


        function handlePlayerDamage(amount) {
            if (isInvincible || gameOver) return;

            player.health -= amount;
            playerHealthDisplay.textContent = Math.max(0, player.health);
            addFloatingText(`-${amount}`, player.x + player.width/2, player.y, 'red');

            if (player.health <= 0) {
                player.health = 0;
                endGame(false); // Player lost
            }
        }

        function checkCollision(rect1, rect2) {
             // Check for AABB collision
             return rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y;
        }

        function endGame(won, message = "GAME OVER") {
            gameOver = true;
            gameWon = won;
            messageOverlay.textContent = message + (won ? "" : "\nPress Enter to Restart");
            messageOverlay.style.display = 'block';
            keys = {}; // Stop movement on game end
        }

        // --- Rendering Functions ---
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

             // Draw background elements if any (simple color for now)
             ctx.fillStyle = '#333';
             ctx.fillRect(0, 0, canvasWidth, canvasHeight);

             if (!gameStarted && !gameOver) {
                 // Start screen is handled by overlay
                 return;
             }
             if (gameOver) {
                  // Game over screen handled by overlay
                 return;
             }

            // Draw Player
             drawEmojiOrRect(player);
             // Draw attack visualization
             if (player.isAttacking) {
                 ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                 // Simple flash effect around player
                 ctx.fillRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
             }

            // Draw Enemies
            enemies.forEach(enemy => {
                drawEmojiOrRect(enemy);
                // Draw health bar for bosses
                if (enemy.isBoss) {
                    drawHealthBar(enemy);
                    // Draw block indicator for Kamran
                    if (enemy.id === 'kamran' && enemy.attackState.blocking) {
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
                        ctx.fillRect(enemy.x - 5, enemy.y - 5, enemy.width + 10, enemy.height + 10);
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('BLOCKING', enemy.x + enemy.width / 2, enemy.y - 15);
                    }
                }
                 // Draw block indicator for Kamran
                 if (enemy.id === 'kamran' && enemy.attackState.blocking) {
                     ctx.fillStyle = 'rgba(100, 100, 255, 0.6)';
                     ctx.beginPath();
                     ctx.roundRect(enemy.x - 5, enemy.y - 5, enemy.width + 10, enemy.height + 10, 5);
                     ctx.fill();
                 }
            });

            // Draw Projectiles
            projectiles.forEach(p => {
                 if (p.type === 'expanding_wave') {
                     ctx.fillStyle = p.color;
                     ctx.beginPath();
                     ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                     ctx.fill();
                     drawEmoji(p.emoji, p.x - p.radius / 2, p.y - p.radius / 2, p.radius);
                 } else if (p.type === 'beam') {
                     ctx.strokeStyle = p.color;
                     ctx.lineWidth = p.width;
                     ctx.beginPath();
                     ctx.moveTo(p.x, p.y);
                     // Point towards player - update target dynamically? For now, fixed target
                     ctx.lineTo(p.targetX, p.targetY);
                     ctx.stroke();
                     ctx.lineWidth = 1; // Reset line width
                 } else if (p.type === 'slow_field') {
                     ctx.fillStyle = p.color;
                     ctx.fillRect(p.x, p.y, p.width, p.height);
                     drawEmoji(p.emoji, p.x + p.width/2 - 15, p.y + p.height/2 - 15, 30);
                 }
                  else {
                     drawEmojiOrRect(p);
                 }
            });

             // Draw Cannons
             cannons.forEach(cannon => {
                 drawEmojiOrRect(cannon);
                 // Draw charge indicator?
                 const chargeRatio = cannon.timer / cannon.cooldown;
                 ctx.fillStyle = 'yellow';
                 ctx.fillRect(cannon.x, cannon.y - 5, cannon.width * chargeRatio, 3);
             });

             // Floating texts are handled by separate HTML elements now
        }

         function drawEmojiOrRect(entity) {
             if (entity.emoji) {
                 drawEmoji(entity.emoji, entity.x, entity.y, Math.max(entity.width, entity.height));
             } else {
                 ctx.fillStyle = entity.color;
                 ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
             }
         }

        function drawEmoji(emoji, x, y, size) {
             ctx.font = `${size * 0.8}px Arial`; // Adjust emoji size relative to entity box
             ctx.textAlign = 'center';
             ctx.textBaseline = 'middle';
             ctx.fillText(emoji, x + size / 2, y + size / 2);
         }

        function drawHealthBar(enemy) {
             const barWidth = enemy.width;
             const barHeight = 5;
             const barX = enemy.x;
             const barY = enemy.y - 10; // Position above the enemy
             const healthRatio = enemy.health / enemy.maxHealth;

             ctx.fillStyle = '#555'; // Background of health bar
             ctx.fillRect(barX, barY, barWidth, barHeight);
             ctx.fillStyle = healthRatio > 0.5 ? 'green' : (healthRatio > 0.2 ? 'orange' : 'red'); // Health bar color
             ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
         }

        // --- Game Loop ---
        function gameLoop(timestamp) {
            if (gameOver) {
                 // Check for restart input
                 if (keys['Enter'] && !gameWon) {
                     startGame(); // Restart the game
                 } else {
                     requestAnimationFrame(gameLoop); // Keep checking for Enter if game over
                 }
                 return; // Don't run game logic if over
            }
             if (!gameStarted) {
                  // Waiting to start, handled by overlay and Enter keydown
                  requestAnimationFrame(gameLoop);
                  return;
             }

              const stage = STAGES[currentStage];
             if (stage.type === 'dialogue') {
                  // Waiting for Enter press in dialogue, handled by keydown
                  requestAnimationFrame(gameLoop);
                  return;
             }


            updatePlayer();
            updateEnemies();
            updateBossState(); // Handle ongoing boss attack states
            updateProjectiles();
            if (stage.hazard === 'cannons') {
                 updateCannons();
            }
            updateFloatingTexts(); // Update opacity/position of HTML elements

            render();

            requestAnimationFrame(gameLoop);
        }

        // --- Initial Setup ---
        // Display start message
        messageOverlay.textContent = "HENRY X PILLOW: The Game.\nPress ENTER to Start";
        messageOverlay.style.display = 'block';
        stageNameDisplay.textContent = STAGES[0].name;
        playerHealthDisplay.textContent = player.maxHealth;
        invincibleStatusDisplay.textContent = isInvincible ? 'ON' : 'OFF';

        // Resize listener
        window.addEventListener('resize', () => {
             canvasWidth = Math.min(window.innerWidth * 0.9, 800);
             canvasHeight = Math.min(window.innerHeight * 0.6, 600);
             canvas.width = canvasWidth;
             canvas.height = canvasHeight;
             // Adjust player position or other elements if needed on resize
             player.x = Math.min(player.x, canvasWidth - player.width);
             player.y = Math.min(player.y, canvasHeight - player.height);
             if(gameStarted && !gameOver) render(); // Re-render immediately after resize if game is active
        });


        // Start checking for input, but wait for Enter to start the actual game logic loop
        requestAnimationFrame(gameLoop); // Start the loop to listen for Enter

    </script>

</body>
</html>