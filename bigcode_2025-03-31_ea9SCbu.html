<!DOCTYPE html>
<html>
<head>
<title>Object Show Displayer - Party In New York</title>
<meta charset="UTF-8">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background-color: #222; /* Dark background */
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    flex-direction: column;
    font-family: sans-serif;
  }
  canvas {
    border: 2px solid #555; /* Slightly darker border */
    background-color: #87CEEB; /* Sky blue background */
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }
  #controls {
    margin-top: 15px;
    background-color: #333;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  }
  textarea {
    width: 640px; /* Match canvas width */
    height: 120px; /* Increased height */
    margin-bottom: 10px;
    font-family: monospace;
    font-size: 14px; /* Slightly larger font */
    background-color: #eee;
    border: 1px solid #444;
    color: #111;
  }
  button {
    padding: 8px 15px; /* Bigger buttons */
    font-size: 14px;
    margin: 0 5px;
    cursor: pointer;
    border: none;
    border-radius: 3px;
    background-color: #4CAF50; /* Green */
    color: white;
    transition: background-color 0.2s ease;
  }
  button:hover {
    background-color: #45a049;
  }
  button:disabled {
    background-color: #aaa;
    cursor: not-allowed;
  }
  #stopButton {
    background-color: #f44336; /* Red */
  }
  #stopButton:hover {
    background-color: #da190b;
  }
  #stopButton:disabled {
    background-color: #aaa;
  }
  #status {
    margin-top: 10px; /* Increased margin */
    font-family: sans-serif;
    font-size: 14px; /* Larger status text */
    color: #eee; /* Light status text */
    min-height: 20px; /* Reserve space */
    display: inline-block;
    background-color: #444;
    padding: 5px 10px;
    border-radius: 3px;
  }
</style>
</head>
<body>

<!-- Hidden Textarea containing the episode script -->
<textarea id="script" style="display: none;">
[0:H]
[0:Size100]
[4:SnapX-280Y-150]
[10:SnapX280Y-150]
[4:S]
[10:S]
[4:SmoothX-200Y-100]
[10:SmoothX200Y-100]
[4T:"Wow, Pizza! We're finally here! Times Square!"]
[10T:"It's even more dazzling and topping-filled than the brochures, Ethan!"]
[7:SnapX0Y160]
[7:Size70]
[7:S]
[7:SmoothX0Y-140]
[7T:"Whoa there, party people! Watch your step! This city keeps you on your peel!"]
[4:SmoothX-210Y-90]
[10:SmoothX210Y-90]
[4T:"Yikes! Thanks for the save, Banana Peel!"]
[10T:"Phew, that was a close slice! Nearly slipped into a dimension of anchovies!"]
[8:SnapX-250Y150]
[8:Size90]
[9:SnapX250Y150]
[9:Size110]
[8:S]
[9:S]
[8:SmoothX-150Y100]
[9:SmoothX150Y100]
[8T:"Hey guys! Heard someone mention... PARTY?! I'm sooo ready to fluff things up!"]
[9T:"Indeed! I have arrived, bringing... structural integrity? And maybe snacks later."]
[4:SmoothX-180Y-80]
[10:SmoothX180Y-80]
[4T:"Pillow! Box! Perfect timing!"]
[10T:"The party's getting layered! Awesome!"]
[7:SmoothX-50Y-130]
[7T:"Alright, let's find a good spot! Maybe near that hot dog stand?"]
[1:SnapX0Y0]
[1:Size150]
[1:H]
[1:SmoothX0Y0]
[1:S]
[1T:"Greetings, assembled objects. A convergence of festive energy signatures led me to this locale. Is this the designated 'Party Zone'?"]
[4:SmoothX-150Y-50]
[10:SmoothX150Y-50]
[8:SmoothX-120Y80]
[9:SmoothX120Y80]
[7:SmoothX0Y-120]
[4T:"Uami Bosim Son! It's really you! Welcome to NYC!"]
[10T:"This is gonna be epic! The ultimate crossover!"]
[1T:"Affirmative. The probability of enjoyment is calculated at 98.7 percent. Let the celebratory protocols commence."]
[1:SmoothX0Y10]
[5:SnapX-280Y-140]
[5:Size70]
[6:SnapX280Y-140]
[6:Size80]
[5:S]
[6:S]
[5:SmoothX-200Y120]
[6:SmoothX200Y120]
[5T:"Pop pop pop! Did someone say party? I'm ready to burst with excitement!"]
[6T:"Chill, everyone. Ice has arrived to keep things cool. Don't melt under the pressure."]
[4:SmoothX-150Y-30]
[10:SmoothX150Y-30]
[8:SmoothX-100Y100]
[9:SmoothX100Y100]
[7:SmoothX50Y-120]
[1:SmoothX0Y20]
[11:SnapX-100Y-160]
[11:Size130]
[11:S]
[11:SmoothX0Y-80]
[11T:"Twice the sunshine, twice the fun! Hello New York!"]
[4T:"Twin Sunflower! Wow, everyone's showing up!"]
[10T:"This party has all the best ingredients!"]
[3:SnapX-150Y160]
[3:Size60]
[2:SnapX150Y160]
[2:Size90]
[3:S]
[2:S]
[3:SmoothX-50Y150]
[2:SmoothX50Y150]
[3T:"Hope I'm not late! Just gotta kick back and enjoy the party!"]
[2T:"Just arrived through the portal... I mean, the window. What's the view from here? Party looks great!"]
[4:SmoothX-130Y-10]
[10:SmoothX130Y-10]
[8:SmoothX-80Y110]
[9:SmoothX80Y110]
[7:SmoothX70Y-110]
[1:SmoothX0Y30]
[5:SmoothX-180Y130]
[6:SmoothX180Y130]
[11:SmoothX0Y-60]
[1T:"Initiating phase two: Festive Movement Patterns. Activate music simulation!"]
[4:SmoothX-100Y0]
[10:SmoothX100Y0]
[8:SmoothX-50Y80]
[9:SmoothX50Y80]
[7:SmoothX90Y-90]
[5:SmoothX-150Y100]
[6:SmoothX150Y100]
[11:SmoothX0Y-40]
[3:SmoothX-30Y130]
[2:SmoothX30Y130]
[4T:"Yeah! Let's dance!"]
[10T:"Spin cycle! Woo!"]
[8T:"Whee! Soft landings guaranteed!"]
[9T:"Executing... awkward shuffling algorithm."]
[5T:"Pop pop pop! Bouncing to the beat!"]
[6T:"Maintaining optimal coolness while grooving."]
[11T:"Photosynthesizing the rhythm!"]
[3T:"Don't tread on me while I two-step!"]
[2T:"Observing dance routines. Fascinating!"]
[7:SmoothX0Y-150]
[7:SmoothX50Y-130]
[7:SmoothX0Y-150]
[7:SmoothX-50Y-130]
[7:SmoothX0Y-150]
[7T:"Woohoo! Electric slide! Peel out!"]
[4:SmoothX-120Y20]
[10:SmoothX120Y20]
[8:SmoothX-70Y100]
[9:SmoothX70Y100]
[1:SmoothX0Y40]
[1T:"Analysis complete: Maximum fun levels achieved."]
[10T:"This was the absolute best trip to New York! Forget deep dish, this is the slice of life!"]
[4T:"Couldn't agree more! Thanks for coming, everyone! Best party ever!"]
[5T:"Pop pop! Bye!"]
[11T:"See you later, sunshines!"]
[7T:"Watch out for peels on your way home!"]
[8T:"Time for a nap after all that excitement!"]
[6T:"Stay cool."]
[3T:"Gotta run!"]
[2T:"Closing window!"]
[9T:"Deconstructing... I mean, leaving!"]
[0:SmoothX0Y250]
[1T:"Farewell until our next convergence."]
[10T:"Bye Ethan!"]
[4T:"Bye Pizza! Bye everyone!"]
[0:Size100]
[0:H]
</textarea>

<canvas id="displayCanvas" width="640" height="360"></canvas>

<div id="controls">
  <button id="playButton">Play Episode</button>
  <button id="stopButton">Stop</button>
  <span id="status">Status: Ready</span>
</div>

<script>
  const canvas = document.getElementById('displayCanvas');
  const ctx = canvas.getContext('2d');
  const scriptTextArea = document.getElementById('script');
  const playButton = document.getElementById('playButton');
  const stopButton = document.getElementById('stopButton');
  const statusSpan = document.getElementById('status');

  const CANVAS_WIDTH = 640;
  const CANVAS_HEIGHT = 360;
  const CENTER_X = CANVAS_WIDTH / 2;
  const CENTER_Y = CANVAS_HEIGHT / 2;

  const SMOOTH_DURATION_MS = 600; // Slightly longer smooth moves
  const COMMAND_DELAY_MS = 50; // Small delay between non-waiting commands
  const POST_SPEECH_DELAY_MS = 100; // Delay after speech ends before next command
  const POST_SMOOTH_DELAY_MS = 100; // Delay after smooth move ends before next command

  let characters = {};
  let scriptLines = [];
  let currentLine = 0;
  let isPlaying = false;
  let animationRequestId = null;
  let commandTimeoutId = null;
  let activeSpeech = null;
  let activeSmoothMoves = 0; // Counter for active smooth animations

  // --- Character Definitions ---
  function initCharacters() {
      characters = {
          // ID: { id, name, x, y, size, visible, targetX, targetY, isSmoothing, smoothStart, startX, startY, voice, emoji, color, drawFunc }
          1: { id: 1, name: "Uami Bosim Son", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ¤–', color: '#4682B4', draw: drawEmoji }, // Steel Blue Robot
          2: { id: 2, name: "Window", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸªŸ', color: '#ADD8E6', draw: drawWindow }, // Light Blue
          3: { id: 3, name: "Shoe", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ‘ž', color: '#8B4513', draw: drawShoe }, // Saddle Brown
          4: { id: 4, name: "Ethan", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ”´', color: '#FF0000', draw: drawCircle }, // Red
          5: { id: 5, name: "Popcorn", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ¿', color: '#FFFACD', draw: drawPopcorn }, // Lemon Chiffon
          6: { id: 6, name: "Ice", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ§Š', color: '#AFEEEE', draw: drawSquare }, // Pale Turquoise
          7: { id: 7, name: "Banana Peel", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸŒ', color: '#FFFF00', draw: drawEmoji }, // Yellow
          8: { id: 8, name: "Pillow", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'â˜ï¸', color: '#FFFFFF', draw: drawPillow }, // White
          9: { id: 9, name: "Box", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ“¦', color: '#D2B48C', draw: drawEmoji }, // Tan Box
          10: { id: 10, name: "Pizza", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸ•', color: '#FFD700', draw: drawEmoji }, // Goldish Crust
          11: { id: 11, name: "Twin Sunflower", x: 0, y: 0, size: 100, visible: false, targetX: 0, targetY: 0, isSmoothing: false, smoothStart: 0, startX: 0, startY: 0, voice: null, emoji: 'ðŸŒ»ðŸŒ»', color: '#FFD700', draw: drawEmoji } // Gold Sunflower
      };
      assignVoices(); // Attempt to assign TTS voices
  }

  function assignVoices() {
    if (!('speechSynthesis' in window)) return;

    const assignVoiceForChar = (char) => {
        const voices = speechSynthesis.getVoices();
        if (voices.length === 0) {
            console.log("Voices not loaded yet for", char.name);
            return; // Voices not ready
        }
        let preferredVoices = [];
        // Simple voice preference hints based on character
        if ([1, 6, 9].includes(char.id)) preferredVoices = ["David", "Zira", "Google UK English Male", "Daniel"]; // More robotic/neutral/male
        else if ([2, 8, 11].includes(char.id)) preferredVoices = ["Samantha", "Google US English", "Zira", "Microsoft Zira"]; // Female/standard
        else preferredVoices = ["Google US English", "Samantha", "Alex"]; // Default pool

        let foundVoice = null;
        // Try preferred names (case-insensitive partial match)
        for (const namePart of preferredVoices) {
            foundVoice = voices.find(v => v.lang.startsWith('en') && v.name.toLowerCase().includes(namePart.toLowerCase()));
            if (foundVoice) break;
        }
        // Fallback to default English voice
        if (!foundVoice) foundVoice = voices.find(v => v.lang.startsWith('en') && v.default);
        // Fallback to first available English voice
        if (!foundVoice) foundVoice = voices.find(v => v.lang.startsWith('en'));

        char.voice = foundVoice || null; // Assign the found voice or null
         if (char.voice) {
            // console.log(`Assigned voice ${char.voice.name} to ${char.name}`);
         } else {
             console.warn(`Could not find suitable English voice for ${char.name}`);
         }
    };

    // Assign voices to all characters
    Object.values(characters).forEach(assignVoiceForChar);
 }

 // Ensure voices are loaded before assignment
 if ('speechSynthesis' in window) {
    if (speechSynthesis.getVoices().length > 0) {
        console.log("Voices already available.");
        assignVoices();
    } else {
         speechSynthesis.onvoiceschanged = () => {
             console.log("Voices loaded.");
             assignVoices();
         };
    }
 }


  // --- Drawing Functions ---
  // (Coordinates x, y are relative to CENTER, Y positive is UP)
  // (Size is percentage, 100 is default ~50px)

  function drawSquare(ctx, x, y, size, color, emoji) {
    const baseSize = 50; // Base pixel size at 100%
    const scaledSize = baseSize * (size / 100);
    const canvasX = CENTER_X + x - scaledSize / 2;
    const canvasY = CENTER_Y - y - scaledSize / 2; // Invert Y and center
    ctx.fillStyle = color;
    ctx.fillRect(canvasX, canvasY, scaledSize, scaledSize);
    ctx.strokeStyle = 'rgba(0,0,0,0.5)'; // Add slight border
    ctx.lineWidth = 1;
    ctx.strokeRect(canvasX, canvasY, scaledSize, scaledSize);
  }

   function drawCircle(ctx, x, y, size, color, emoji) {
    const baseRadius = 25; // Base pixel radius at 100%
    const radius = baseRadius * (size / 100);
    const canvasX = CENTER_X + x;
    const canvasY = CENTER_Y - y; // Invert Y
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(canvasX, canvasY, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)'; // Add slight border
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  function drawWindow(ctx, x, y, size, color) {
    const baseSize = 50;
    const scaledSize = baseSize * (size / 100);
    const canvasX = CENTER_X + x - scaledSize / 2;
    const canvasY = CENTER_Y - y - scaledSize / 2;
    ctx.fillStyle = color;
    ctx.fillRect(canvasX, canvasY, scaledSize, scaledSize);
    ctx.strokeStyle = '#444'; // Darker frame lines
    ctx.lineWidth = Math.max(1, scaledSize * 0.08); // Scale line width
    // Frame border
    ctx.strokeRect(canvasX, canvasY, scaledSize, scaledSize);
    // Cross lines
    ctx.beginPath();
    ctx.moveTo(canvasX + scaledSize / 2, canvasY);
    ctx.lineTo(canvasX + scaledSize / 2, canvasY + scaledSize);
    ctx.moveTo(canvasX, canvasY + scaledSize / 2);
    ctx.lineTo(canvasX + scaledSize, canvasY + scaledSize / 2);
    ctx.stroke();
  }

  function drawShoe(ctx, x, y, size, color) {
    const scale = size / 100;
    const w = 50 * scale;
    const h = 30 * scale;
    const canvasX = CENTER_X + x - w / 2; // Center horizontally
    const canvasY = CENTER_Y - y - h / 2; // Center vertically

    ctx.fillStyle = color;
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    // Simple L-shape approximation for shoe
    ctx.moveTo(canvasX, canvasY); // Top back
    ctx.lineTo(canvasX, canvasY + h); // Bottom back
    ctx.lineTo(canvasX + w, canvasY + h); // Bottom front
    ctx.lineTo(canvasX + w, canvasY + h * 0.7); // Start curve up
    ctx.quadraticCurveTo(canvasX + w * 0.9, canvasY + h * 0.4, canvasX + w * 0.6, canvasY); // Top curve
    ctx.lineTo(canvasX + w * 0.2, canvasY); // Top flat part
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  function drawPopcorn(ctx, x, y, size, color) {
     const scale = size / 100;
     const r = 25 * scale;
     const canvasX = CENTER_X + x;
     const canvasY = CENTER_Y - y;
     ctx.fillStyle = color; // Main popcorn color
     ctx.strokeStyle = 'rgba(0,0,0,0.3)';
     ctx.lineWidth = 1;
     // Base shape
     ctx.beginPath();
     ctx.arc(canvasX, canvasY, r*0.8, 0, Math.PI * 2);
     ctx.fill();
     ctx.stroke();
     // Add some fluffy bits
     for(let i = 0; i < 5; i++) {
         const angle = Math.random() * Math.PI * 2;
         const dist = r * (0.5 + Math.random() * 0.6);
         const blobR = r * (0.3 + Math.random() * 0.3);
         ctx.beginPath();
         ctx.arc(canvasX + Math.cos(angle) * dist, canvasY + Math.sin(angle) * dist, blobR, 0, Math.PI * 2);
         // Add some yellow butter color variation
         ctx.fillStyle = (Math.random() < 0.4) ? '#FFEC8B' : color; // Light yellow or main color
         ctx.fill();
         ctx.stroke();
     }
      ctx.fillStyle = color; // Reset fill color
  }

   function drawPillow(ctx, x, y, size, color) {
    const scale = size / 100;
    const w = 60 * scale;
    const h = 40 * scale;
    const r = 10 * scale; // corner radius
    const canvasX = CENTER_X + x - w / 2;
    const canvasY = CENTER_Y - y - h / 2;

    ctx.fillStyle = color;
    ctx.strokeStyle = '#CCCCCC'; // Light grey border
    ctx.lineWidth = 1.5;
    // Rounded rectangle path
    ctx.beginPath();
    ctx.moveTo(canvasX + r, canvasY);
    ctx.lineTo(canvasX + w - r, canvasY);
    ctx.quadraticCurveTo(canvasX + w, canvasY, canvasX + w, canvasY + r);
    ctx.lineTo(canvasX + w, canvasY + h - r);
    ctx.quadraticCurveTo(canvasX + w, canvasY + h, canvasX + w - r, canvasY + h);
    ctx.lineTo(canvasX + r, canvasY + h);
    ctx.quadraticCurveTo(canvasX, canvasY + h, canvasX, canvasY + h - r);
    ctx.lineTo(canvasX, canvasY + r);
    ctx.quadraticCurveTo(canvasX, canvasY, canvasX + r, canvasY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Add a subtle crease/shadow for fluffiness
     ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
     ctx.beginPath();
     ctx.ellipse(CENTER_X + x, CENTER_Y - y, w * 0.4, h * 0.35, 0, 0, Math.PI * 2);
     ctx.fill();
  }

  function drawEmoji(ctx, x, y, size, color, emoji) {
    const baseFontSize = 50; // Adjust base font size for emojis
    const scaledSize = baseFontSize * (size / 100);
    const canvasX = CENTER_X + x;
    const canvasY = CENTER_Y - y; // Invert Y
    ctx.font = `${scaledSize}px Arial`; // Use a common font
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle'; // Center emoji vertically
    ctx.fillText(emoji, canvasX, canvasY);
  }


  // --- Animation Loop ---
  function gameLoop(timestamp) {
    let stillAnimating = false;

    // Clear canvas
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    // Optional: Draw a simple background if needed
    // ctx.fillStyle = '#87CEEB'; // Sky Blue
    // ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Update and draw characters
    for (const id in characters) {
        const char = characters[id];

        // Update position for smoothing
        if (char.isSmoothing) {
            const elapsed = timestamp - char.smoothStart;
            const progress = Math.min(elapsed / SMOOTH_DURATION_MS, 1);
            // Ease in-out cubic interpolation
            const easedProgress = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            char.x = char.startX + (char.targetX - char.startX) * easedProgress;
            char.y = char.startY + (char.targetY - char.startY) * easedProgress;

            if (progress >= 1) {
                char.isSmoothing = false;
                char.x = char.targetX;
                char.y = char.targetY;
                activeSmoothMoves--; // Decrement active move counter
                // Check if this was the last animation and trigger next command if appropriate
                 if (isPlaying && activeSmoothMoves === 0 && activeSpeech === null) {
                     clearTimeout(commandTimeoutId);
                     commandTimeoutId = setTimeout(processNextLine, POST_SMOOTH_DELAY_MS);
                 }
            } else {
                stillAnimating = true; // An animation is still in progress
            }
        }

        // Draw character if visible
        if (char.visible) {
             if (char.draw) {
                 char.draw(ctx, char.x, char.y, char.size, char.color, char.emoji);
             }
        }
    }

     // Keep the loop running if script is playing OR if animations are still happening
     if (isPlaying || stillAnimating) {
        animationRequestId = requestAnimationFrame(gameLoop);
     } else {
         animationRequestId = null; // Stop loop if script stopped and animations are done
         console.log("Animation loop stopped.");
          if (!isPlaying) { // Ensure status reflects idle state if stopped manually
             statusSpan.textContent = "Status: Idle / Finished";
          }
     }
  }

  // --- Command Processing ---
  function processNextLine() {
      // Stop processing if script is no longer playing
      if (!isPlaying) {
          console.log("Attempted to process line while not playing. Stopping.");
          return;
      }
      // Check if waiting for speech or animation
      if (activeSpeech !== null || activeSmoothMoves > 0) {
          // console.log(`Waiting... Speech: ${activeSpeech !== null}, Smooth Moves: ${activeSmoothMoves}`);
          // The loop/callbacks will trigger the next call when ready
          return;
      }

      if (currentLine >= scriptLines.length) {
          stopScript("Script finished.");
          return;
      }

      const command = scriptLines[currentLine].trim();
      statusSpan.textContent = `Line ${currentLine + 1}: ${command}`;
      console.log(`Executing line ${currentLine + 1}: ${command}`);
      currentLine++; // Increment line counter *before* potential async waits

      let commandProcessed = false;
      let requiresSyncDelay = false; // Does this command require a standard delay before the next?
      let requiresSpeechWait = false; // Wait specifically for TTS?
      let startedSmoothMove = false; // Did this command start a smooth move?

      try {
          // Match command patterns
          const hideShowMatch = command.match(/^\[(\d+):([HS])\]$/);
          const sizeMatch = command.match(/^\[(\d+):Size(\d+(\.\d+)?)\]$/); // Allow decimal sizes
          const snapMatch = command.match(/^\[(\d+):SnapX(-?\d+)Y(-?\d+)\]$/);
          const smoothMatch = command.match(/^\[(\d+):SmoothX(-?\d+)Y(-?\d+)\]$/);
          const ttsMatch = command.match(/^\[(\d+)T:"(.*)"\]$/s); // Allow quotes, s flag for multiline

          const getTargetChars = (id) => {
              if (id === 0) return Object.values(characters);
              return characters[id] ? [characters[id]] : [];
          };

          if (hideShowMatch) {
              const id = parseInt(hideShowMatch[1]);
              const action = hideShowMatch[2];
              getTargetChars(id).forEach(char => {
                  char.visible = (action === 'S');
              });
              commandProcessed = true;
              requiresSyncDelay = true;
          } else if (sizeMatch) {
              const id = parseInt(sizeMatch[1]);
              const size = parseFloat(sizeMatch[2]);
               getTargetChars(id).forEach(char => {
                  char.size = Math.max(1, size); // Prevent zero or negative size
               });
              commandProcessed = true;
              requiresSyncDelay = true;
          } else if (snapMatch) {
              const id = parseInt(snapMatch[1]);
              const x = parseInt(snapMatch[2]);
              const y = parseInt(snapMatch[3]);
              getTargetChars(id).forEach(char => {
                  if (char.isSmoothing) activeSmoothMoves--; // Cancel existing smooth move for this char
                  char.x = x;
                  char.y = y;
                  char.targetX = x;
                  char.targetY = y;
                  char.isSmoothing = false;
              });
              commandProcessed = true;
              requiresSyncDelay = true;
          } else if (smoothMatch) {
              const id = parseInt(smoothMatch[1]);
              const x = parseInt(smoothMatch[2]);
              const y = parseInt(smoothMatch[3]);

              const charsToMove = getTargetChars(id);
              charsToMove.forEach(char => {
                   if (!char.isSmoothing) activeSmoothMoves++; // Only count new moves
                   char.targetX = x;
                   char.targetY = y;
                   char.startX = char.x;
                   char.startY = char.y;
                   char.smoothStart = performance.now();
                   char.isSmoothing = true;
              });
               if (charsToMove.length > 0) {
                   startedSmoothMove = true; // Indicate a move was initiated
               }
              commandProcessed = true;
              // Wait handled by activeSmoothMoves counter and gameLoop callback
          } else if (ttsMatch) {
              const id = parseInt(ttsMatch[1]);
              const text = ttsMatch[2].replace(/\\"/g, '"'); // Handle escaped quotes if needed
              const targetChar = characters[id];

              if (targetChar && 'speechSynthesis' in window) {
                  speechSynthesis.cancel(); // Cancel any previous speech globally

                  const utterance = new SpeechSynthesisUtterance(text);
                  if (targetChar.voice) {
                      utterance.voice = targetChar.voice;
                  } else {
                      console.warn(`No assigned voice for ${targetChar.name}, using default.`);
                  }
                  utterance.pitch = 1.0; // Default pitch
                  utterance.rate = 1.0;  // Default rate

                  activeSpeech = utterance; // Track active speech

                  utterance.onend = () => {
                      console.log(`Speech finished: "${text}"`);
                      activeSpeech = null;
                      // Only proceed if script is still playing and no animations are pending
                      if (isPlaying && activeSmoothMoves === 0) {
                          clearTimeout(commandTimeoutId);
                          commandTimeoutId = setTimeout(processNextLine, POST_SPEECH_DELAY_MS);
                      } else if (isPlaying) {
                          // Waiting for smooth moves to finish
                          // console.log("Speech ended, but waiting for smooth moves.");
                      }
                  };

                  utterance.onerror = (event) => {
                      console.error("SpeechSynthesisUtterance.onerror:", event);
                      activeSpeech = null;
                      if (isPlaying && activeSmoothMoves === 0) {
                        clearTimeout(commandTimeoutId);
                        commandTimeoutId = setTimeout(processNextLine, POST_SPEECH_DELAY_MS); // Proceed even on error
                      }
                  };

                  // Make the character visually "talk" (e.g., subtle size pulse) - Optional Enhancement
                  // targetChar.isTalking = true; // Add this state if implementing visual cue
                  // setTimeout(() => { if (targetChar) targetChar.isTalking = false; }, 200); // Simple pulse example

                  speechSynthesis.speak(utterance);
                  commandProcessed = true;
                  requiresSpeechWait = true; // Wait handled by onend callback
              } else if (!targetChar) {
                   console.warn(`TTS command ignored: Character ID ${id} not found.`);
                   commandProcessed = true;
                   requiresSyncDelay = true; // Treat as immediate command if char not found
              } else {
                  console.warn("TTS command ignored: Speech Synthesis not supported or unavailable.");
                   commandProcessed = true;
                   requiresSyncDelay = true; // Treat as immediate
              }
          }

          if (!commandProcessed && command !== "") {
              console.warn(`Unknown command format on line ${currentLine}: ${command}`);
              requiresSyncDelay = true; // Move to next line even if unknown
          }

      } catch (error) {
          console.error(`Error processing command "${command}" on line ${currentLine}:`, error);
          stopScript("Error occurred.");
          return; // Stop processing on error
      }

       // Start animation loop if not already running and a smooth move started
      if (startedSmoothMove && !animationRequestId) {
          console.log("Starting animation loop.");
          animationRequestId = requestAnimationFrame(gameLoop);
      } else if (!animationRequestId && isPlaying) {
          // If loop isn't running but should be (e.g., for drawing static changes), run one frame
          requestAnimationFrame(gameLoop);
      }

      // --- Schedule Next Command ---
      // Clear any previous timeout first
      clearTimeout(commandTimeoutId);

      if (isPlaying) {
          if (requiresSyncDelay) {
              // Standard small delay for non-waiting commands
              commandTimeoutId = setTimeout(processNextLine, COMMAND_DELAY_MS);
          } else if (!requiresSpeechWait && !startedSmoothMove) {
              // If it wasn't a waiting command (TTS/Smooth) and not marked for sync delay (e.g. unknown cmd handled)
              // Proceed quickly, but still use timeout 0 to yield thread
               commandTimeoutId = setTimeout(processNextLine, 0);
          }
          // If it requires Speech wait, the onend callback handles it.
          // If it started a Smooth move, the gameLoop decrementing activeSmoothMoves handles it.
      }
  }


   // --- Control Functions ---
  function playScript() {
      if (isPlaying) return;
      console.log("Play button clicked - Starting Episode");
      isPlaying = true;
      playButton.disabled = true;
      stopButton.disabled = false;
      // Keep textarea hidden scriptTextArea.disabled = true;
      statusSpan.textContent = "Status: Playing...";

      scriptLines = scriptTextArea.value.split('\n').filter(line => line.trim() !== '');
      if (scriptLines.length === 0) {
           stopScript("Script is empty.");
           return;
      }
      currentLine = 0;
      activeSmoothMoves = 0; // Reset counter

      initCharacters(); // Reset characters to initial state
      clearTimeout(commandTimeoutId);
      if ('speechSynthesis' in window) speechSynthesis.cancel();
      activeSpeech = null;

      // Start processing the first line
      processNextLine();

       // Ensure the animation loop starts if it isn't running (for initial state drawing)
       if (!animationRequestId) {
          console.log("Starting animation loop for playback.");
          animationRequestId = requestAnimationFrame(gameLoop);
       }
  }

  function stopScript(message = "Stopped by user.") {
       console.log("Stop action triggered:", message);
       if (!isPlaying && !animationRequestId && activeSmoothMoves === 0) {
           console.log("Already fully stopped.");
           return; // Already idle
       }

      isPlaying = false; // Primary flag to stop processing new commands

      playButton.disabled = false;
      stopButton.disabled = true;
      // scriptTextArea.disabled = false;
      statusSpan.textContent = `Status: ${message}`;

      clearTimeout(commandTimeoutId); // Stop any pending command timeouts
      commandTimeoutId = null;

      if ('speechSynthesis' in window) speechSynthesis.cancel(); // Stop any ongoing speech
      activeSpeech = null;

      // Let ongoing smooth animations finish naturally.
      // The animation loop will stop itself when isPlaying is false and animations complete.
      // If an abrupt visual stop is desired, uncomment below:
      /*
      if (animationRequestId) {
          cancelAnimationFrame(animationRequestId);
          animationRequestId = null;
          console.log("Animation loop force stopped.");
      }
      // Reset smoothing states to freeze characters
      activeSmoothMoves = 0;
      for (const id in characters) {
         characters[id].isSmoothing = false;
      }
      // Optionally redraw one last time in the stopped state
      // requestAnimationFrame(gameLoop); // Might cause issues if loop logic expects isPlaying
      */
      console.log("Script execution stopped. Animations may continue to finish.");
  }

  // --- Event Listeners ---
  playButton.addEventListener('click', playScript);
  stopButton.addEventListener('click', () => stopScript("Stopped by user."));

  // --- Initial Setup ---
  stopButton.disabled = true; // Initially stopped
  initCharacters(); // Initialize character data (voices assigned asynchronously)

  // Draw initial empty state or scene setup (optional)
  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  // Draw a simple ground plane maybe
  ctx.fillStyle = "#228B22"; // Forest Green
  ctx.fillRect(0, CANVAS_HEIGHT * 0.8, CANVAS_WIDTH, CANVAS_HEIGHT * 0.2);
  ctx.fillStyle = "#A9A9A9"; // Dark Gray Sidewalk
  ctx.fillRect(0, CANVAS_HEIGHT * 0.75, CANVAS_WIDTH, CANVAS_HEIGHT * 0.05);

  console.log("Object Show Displayer Initialized. Ready to play.");
  statusSpan.textContent = "Status: Ready";

</script>

</body>
</html>