<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Ball</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky blue */
            font-family: 'Comic Sans MS', cursive, sans-serif; /* Game-like font */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #333;
        }

        #game-container {
            width: 800px;
            height: 600px;
            background: linear-gradient(to bottom, #87CEEB 70%, #f0e68c 70%); /* Sky and vague ground */
            position: relative;
            overflow: hidden;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100' viewBox='0 0 100 100'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.1'%3E%3Cpath opacity='.5' d='M96 95h4v1h-4v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4h-9v4h-1v-4H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15v-9H0v-1h15V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h9V0h1v15h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9h4v1h-4v9zm-1 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm9-10v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm9-10v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm9-10v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-10 0v-9h-9v9h9zm-9-10h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9zm10 0h9v-9h-9v9z'/%3E%3Cpath d='M6 5V0H5v5H0v1h5v94h1V6h94V5H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            background-repeat: repeat;
        }

        .screen {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            left: 0;
            background: rgba(135, 206, 235, 0.8); /* Semi-transparent sky overlay */
        }

        #main-menu {
            display: flex; /* Show initially */
            background: linear-gradient(to bottom, #87CEEB 0%, #add8e6 50%, #f0e68c 100%); /* Sky to ground gradient */
        }

        #main-menu h1 {
            font-size: 80px;
            color: red;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            position: absolute;
            top: 50px;
            left: 50px;
            margin: 0;
        }
        
        #king-logo {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 30px;
            font-weight: bold;
            color: #228B22; /* ForestGreen */
            text-shadow: 1px 1px 1px #fff;
        }
        #king-logo span {
            color: gold;
            font-size: 40px;
            display: block;
            margin-bottom: -15px;
        }

         #main-menu-options {
            position: absolute;
            top: 200px;
            left: 50px;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #main-menu-options li {
            margin-bottom: 15px;
        }

        #main-menu-options button {
            background: none;
            border: none;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-size: 36px;
            font-weight: bold;
            color: yellow;
            text-shadow: 2px 2px 0 #a0522d, -1px -1px 0 #a0522d, 1px -1px 0 #a0522d, -1px 1px 0 #a0522d, 1px 1px 0 #a0522d;
            cursor: pointer;
            transition: transform 0.1s ease;
        }
        #main-menu-options button:hover {
            transform: scale(1.1);
            color: orange;
        }

        .menu-character {
            position: absolute;
            right: 100px;
            bottom: 100px;
            font-size: 80px; /* Emoji size */
        }

        .menu-ground {
             position: absolute;
             bottom: 0;
             left:0;
             width: 100%;
             height: 120px; /* Adjust height as needed */
             background-color: #8B4513; /* SaddleBrown */
             border-top: 10px solid #556B2F; /* DarkOliveGreen for grass */
        }
         .menu-hill {
             position: absolute;
             bottom: 115px;
             right: 50px;
             width: 250px;
             height: 150px;
             background-color: #8B4513;
             border-radius: 100px 100px 0 0 / 50px 50px 0 0;
             border-top: 10px solid #556B2F;
         }
         .menu-plant {
             position: absolute;
             bottom: 120px;
             font-size: 30px;
         }


        #level-select {
             background: linear-gradient(to bottom, #87CEEB 0%, #add8e6 100%);
        }
        #level-select h2 {
            font-size: 40px;
            color: orange;
            text-shadow: 2px 2px #8B4513;
            margin-bottom: 20px;
        }
        #level-grid {
            display: grid;
            grid-template-columns: repeat(12, 40px);
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .level-button {
            width: 40px;
            height: 40px;
            background-color: #90EE90; /* LightGreen */
            border: 2px solid #228B22; /* ForestGreen */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .level-button:hover {
            background-color: #32CD32; /* LimeGreen */
        }
        .level-button.locked {
            background-color: grey;
            cursor: not-allowed;
        }
         #level-preview {
            width: 300px;
            height: 150px;
            border: 3px solid #555;
            margin-bottom: 10px;
            background: #add8e6; /* Light blue inner sky */
            position: relative;
            overflow: hidden;
        }
        #level-preview-content {
            position: absolute;
             bottom: 0; left:0; right:0; height: 40px; background: #8B4513; border-top: 5px solid #556B2F;
             display: flex; align-items: center; justify-content: space-around;
        }
         #level-preview-info {
            font-size: 18px;
            color: #fff;
            text-shadow: 1px 1px #333;
         }

        #game-screen {
            background: none; /* Transparent to show container background */
        }

        #game-world {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
         }

        .game-object {
            position: absolute;
            box-sizing: border-box;
        }

        #player {
            width: 30px;
            height: 30px;
            background-color: red;
            border-radius: 50%;
            border: 2px solid darkred;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
        }
         /* Simple eyes for player */
         #player::before, #player::after {
             content: '';
             position: absolute;
             width: 5px;
             height: 5px;
             background-color: white;
             border-radius: 50%;
             border: 1px solid black;
             top: 8px;
         }
         #player::before { left: 7px; }
         #player::after { right: 7px; }
         /* Pupil */
          #player > div {
             position: absolute;
             width: 2px;
             height: 2px;
             background-color: black;
             border-radius: 50%;
             top: 10px;
          }
          #player > div.left { left: 8px; }
          #player > div.right { right: 8px; }


        .platform {
            background-color: #8B4513; /* SaddleBrown */
            border-top: 5px solid #228B22; /* ForestGreen */
            z-index: 1;
        }
        
        .stone-platform {
            background: #A9A9A9; /* DarkGray */
             border: 2px solid #696969;
             /* Simple texture */
             background-image: linear-gradient(45deg, #808080 25%, transparent 25%), linear-gradient(-45deg, #808080 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #808080 75%), linear-gradient(-45deg, transparent 75%, #808080 75%);
             background-size: 10px 10px;
             background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
             z-index: 1;
        }
        
        .brick-platform {
             background: #CD5C5C; /* IndianRed */
             border: 1px solid #8B0000; /* DarkRed */
             background-image: linear-gradient(to right, grey 1px, transparent 1px), linear-gradient(to bottom, grey 1px, transparent 1px);
             background-size: 20px 10px; /* Brick size */
             z-index: 1;
        }


        .goal {
            font-size: 30px; /* Emoji size */
            z-index: 5;
        }

        .spike {
             width: 0;
             height: 0;
             border-left: 10px solid transparent;
             border-right: 10px solid transparent;
             border-bottom: 15px solid red;
             z-index: 2;
        }
        .spike-up {
            border-bottom: none;
            border-top: 15px solid red;
        }
        .spike-left {
            border-bottom: 10px solid transparent;
            border-top: 10px solid transparent;
            border-right: 15px solid red;
            border-left: none;
        }
         .spike-right {
            border-bottom: 10px solid transparent;
            border-top: 10px solid transparent;
            border-left: 15px solid red;
            border-right: none;
        }


        .hazard { /* Generic hazard class */
            z-index: 5;
        }

        .moving-platform {
             animation: moveHorizontally 4s linear infinite alternate;
        }
        
        .moving-platform-vertical {
             animation: moveVertically 3s linear infinite alternate;
        }

        .pendulum {
            background-color: grey;
            border-radius: 50%;
            transform-origin: top center;
            animation: swing 3s ease-in-out infinite alternate;
            z-index: 3;
        }
        .pendulum-rope {
            position: absolute;
            height: 100px; /* Adjust based on level */
            width: 2px;
            background-color: #555;
            left: 50%;
            transform: translateX(-50%);
            top: -100px; /* Position above the ball */
            z-index: 2;
         }


        .button {
             width: 20px;
             height: 20px;
             border: 2px solid darkblue;
             background-color: blue;
             cursor: pointer;
             z-index: 5;
        }
         .button.pressed {
             background-color: lightblue;
         }
         .button.green { background-color: green; border-color: darkgreen;}
         .button.green.pressed { background-color: lightgreen;}

         .triggerable {
             opacity: 1;
             transition: opacity 0.5s ease;
         }
         .triggerable.hidden {
             opacity: 0;
             pointer-events: none;
         }


         .car {
             width: 60px;
             height: 35px;
             background-color: blueviolet;
             border: 2px solid darkviolet;
             border-radius: 5px 5px 0 0;
             position: relative;
             z-index: 8;
         }
         .car::before, .car::after { /* Wheels */
             content: '';
             position: absolute;
             width: 15px;
             height: 15px;
             background: #333;
             border-radius: 50%;
             bottom: -8px;
             border: 2px solid #111;
         }
         .car::before { left: 5px; }
         .car::after { right: 5px; }
         .car-body {
            position: absolute;
            width: 30px; height: 20px;
            background: blueviolet;
            top: -15px; left: 15px;
            border: 2px solid darkviolet;
            border-bottom: none;
         }


         .train-cart {
             border: 2px solid grey;
             background-color: lightgrey;
             height: 30px;
             position: relative;
             z-index: 1;
         }
         .train-cart::before, .train-cart::after { /* Wheels */
             content: '';
             position: absolute;
             width: 10px;
             height: 10px;
             background: #555;
             border-radius: 50%;
             bottom: -7px;
         }
          .train-cart::before { left: 10%; }
          .train-cart::after { right: 10%; }

        .game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .game-ui * {
            pointer-events: auto; /* Enable pointer events for children */
        }


        #level-title {
            font-size: 24px;
            color: white;
            text-shadow: 1px 1px #333;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #game-controls button {
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #ccc;
            padding: 5px 10px;
            margin-left: 5px;
            cursor: pointer;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            border-radius: 3px;
        }
        #game-controls button:hover {
            background-color: white;
        }

         #pause-overlay {
             background: rgba(0, 0, 0, 0.7);
             color: white;
             font-size: 50px;
             text-align: center;
             z-index: 200;
         }
         #pause-overlay p {
             margin-bottom: 20px;
         }
         #pause-overlay button {
             font-size: 20px;
             padding: 10px 20px;
             margin: 0 10px;
             cursor: pointer;
         }


        /* Animations */
        @keyframes moveHorizontally {
            from { transform: translateX(0); }
            to { transform: translateX(100px); } /* Adjust distance */
        }
        @keyframes moveVertically {
            from { transform: translateY(0); }
            to { transform: translateY(-80px); } /* Adjust distance */
        }
        @keyframes swing {
            from { transform: rotate(-30deg); }
            to { transform: rotate(30deg); }
        }

        /* Very simple cloud shapes */
        .cloud {
            position: absolute;
            background: white;
            border-radius: 50%;
            opacity: 0.8;
            z-index: -1; /* Behind everything */
            filter: blur(1px);
        }
        .cloud.c1 { width: 100px; height: 40px; top: 50px; left: 10%; animation: drift 60s linear infinite; }
        .cloud.c2 { width: 150px; height: 50px; top: 120px; left: 70%; animation: drift 80s linear infinite reverse; }
        .cloud.c3 { width: 80px; height: 30px; top: 80px; left: 40%; animation: drift 70s linear infinite; }

        @keyframes drift {
            from { transform: translateX(-150px); }
            to { transform: translateX(850px); }
        }

    </style>
</head>
<body>
    <div id="game-container">
        <!-- Clouds -->
        <div class="cloud c1"></div>
        <div class="cloud c2"></div>
        <div class="cloud c3"></div>

        <!-- Main Menu Screen -->
        <div id="main-menu" class="screen">
            <h1>Red ball</h1>
             <div id="king-logo"><span>👑</span>King.com</div>
             <div class="menu-ground"></div>
             <div class="menu-hill"></div>
             <div class="menu-plant" style="left: 300px;">🌿</div>
             <div class="menu-plant" style="left: 500px;">🌿</div>
            <ul id="main-menu-options">
                <li><button onclick="game.startGame()">Play</button></li>
                <li><button onclick="alert('More Games functionality not implemented.')">More games</button></li>
                <li><button onclick="alert('Credits: Inspired by the Red Ball game. Developed by AI.')">Credits</button></li>
                <li><button onclick="alert('Highscore functionality not implemented.')">Highscore</button></li>
                <li><button onclick="alert('Download functionality not implemented.')">Download</button></li>
                <li><button onclick="alert('Walkthrough functionality not implemented.')">Walkthrough</button></li>
            </ul>
            <div class="menu-character">🔴</div>
        </div>

        <!-- Level Select Screen -->
        <div id="level-select" class="screen">
            <h2>Select level</h2>
            <div id="level-grid">
                <!-- Level buttons will be generated here -->
            </div>
            <div id="level-preview">
                <div id="level-preview-content"></div>
            </div>
            <div id="level-preview-info">Select the level you want to play!</div>
             <button onclick="game.showScreen('main-menu')" style="margin-top: 20px; padding: 10px 15px; font-size: 16px;">Back to Menu</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <div class="game-ui">
                <div id="level-title">Level 1: Test</div>
                 <div id="game-controls">
                    <button onclick="game.skipLevel()">Skip Level</button>
                    <button onclick="game.togglePause()">Pause (P)</button>
                    <button onclick="game.restartLevel()">Restart (R)</button>
                    <button onclick="game.quitLevel()">Quit (Esc)</button>
                </div>
            </div>
            <div id="game-world">
                <!-- Game objects will be added here by JavaScript -->
                 <div id="player" class="game-object">
                    <div class="left"></div>
                    <div class="right"></div>
                 </div>
            </div>
        </div>

        <!-- Pause Overlay -->
        <div id="pause-overlay" class="screen">
            <p>Paused</p>
            <button onclick="game.togglePause()">Resume</button>
            <button onclick="game.restartLevel()">Restart</button>
            <button onclick="game.quitLevel()">Quit to Level Select</button>
        </div>

    </div>

    <script>
        const game = {
            container: document.getElementById('game-container'),
            world: document.getElementById('game-world'),
            playerElement: document.getElementById('player'),
            levelTitleElement: document.getElementById('level-title'),
            screens: {
                menu: document.getElementById('main-menu'),
                levelSelect: document.getElementById('level-select'),
                game: document.getElementById('game-screen'),
                pause: document.getElementById('pause-overlay'),
            },
            levelGrid: document.getElementById('level-grid'),
            levelPreview: document.getElementById('level-preview-content'),
            levelPreviewInfo: document.getElementById('level-preview-info'),

            // Game State
            currentScreen: 'main-menu',
            currentLevelIndex: 0,
            maxUnlockedLevel: 0, // Start with level 1 unlocked
            isPaused: false,
            gameLoopId: null,
            keys: {},

            // Physics Constants (Simplified)
            gravity: 0.5,
            friction: 0.85,
            moveSpeed: 3,
            jumpPower: -10,
            maxFallSpeed: 10,

            // Player State
            player: {
                x: 100,
                y: 400,
                vx: 0,
                vy: 0,
                width: 30,
                height: 30,
                onGround: false,
                hasCar: false, // Specific for car levels
                carElement: null,
            },

            levelData: [
                // --- Level Data Structure ---
                // {
                //   name: "Level Name",
                //   brief: "Short description",
                //   playerStart: { x: 100, y: 400 },
                //   goal: { x: 700, y: 420 },
                //   platforms: [ { x: 0, y: 500, width: 800, height: 100, type: 'grass' }, ... ],
                //   spikes: [ { x: 300, y: 485, type: 'up' }, ... ],
                //   hazards: [ { x: 400, y: 200, width: 50, height: 50, type: 'pendulum', ropeLength: 150 }, ...],
                //   buttons: [ { x: 200, y: 480, targetId: 'wall1' } ],
                //   triggerables: [ { id: 'wall1', x: 500, y: 400, width: 20, height: 100, type: 'stone' } ]
                //   hints: [ { text: "Use W to Jump", x: 150, y: 350 } ]
                //   // ... other level specific elements
                // }
                // -----------------------------

                // Level 1: Move and Jump (Simplified Recreation)
                {
                    name: "Level 1: Move and Jump", brief: "🚩 Basic movement", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 230 },
                    platforms: [
                        { x: 0, y: 450, width: 200, height: 150, type: 'grass' },
                        { x: 350, y: 450, width: 450, height: 150, type: 'grass' },
                        { x: 400, y: 300, width: 100, height: 20, type: 'stone' } // Obstacle block
                    ],
                    spikes: [], hazards: [], buttons: [], triggerables: [],
                    hints: [
                        { text: "Use Left/Right or A/D to move", x: 50, y: 380 },
                        { text: "Use Up or W to jump", x: 400, y: 380 },
                        { text: "This is the level goal", x: 650, y: 180 }
                    ]
                },
                // Level 2: Funny Ball (Simplified Recreation)
                {
                    name: "Level 2: Funny ball", brief: "🚩 Checkpoints & Hazards", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 400 },
                    platforms: [
                        { x: 0, y: 450, width: 150, height: 150, type: 'grass' },
                        { x: 250, y: 450, width: 150, height: 150, type: 'grass' }, // With ramp
                        { x: 500, y: 450, width: 150, height: 150, type: 'grass' },
                        { x: 750, y: 450, width: 50, height: 150, type: 'grass' }, // Goal platform
                        // Moving platform placeholder
                         { x: 600, y: 350, width: 100, height: 20, type: 'stone', moving: 'horizontal', moveDist: 100, moveSpeed: 2 }
                    ],
                    spikes: [],
                    hazards: [
                         // Ramp on platform 2
                         { type: 'ramp', x: 250, y: 400, width: 50, height: 50 },
                         // Wrecking ball placeholder
                         { type: 'pendulum', x: 575, y: 300, width: 40, height: 40, ropeLength: 120}
                    ],
                     checkpoints: [ { x: 350, y: 420 } ], // Checkpoint flag
                    buttons: [], triggerables: [],
                    hints: [
                        { text: "Use 'R' to restart", x: 50, y: 350 },
                        { text: "Use 'P' to pause", x: 50, y: 370 },
                        { text: "Use 'Esc' to quit", x: 50, y: 390 },
                        { text: "Check point", x: 300, y: 380 },
                        { text: "Wait for moving platform", x: 600, y: 300 },
                    ]
                },
                 // Level 3: Lifts and Thorns (Simplified Recreation)
                {
                    name: "Level 3: Lifts and thorns", brief: "🚩 Spikes & Lifts", playerStart: { x: 50, y: 150 }, goal: { x: 700, y: 130 },
                    platforms: [
                        { x: 0, y: 200, width: 150, height: 400, type: 'grass' },
                        { x: 250, y: 200, width: 200, height: 400, type: 'grass' },
                        { x: 550, y: 200, width: 250, height: 400, type: 'grass' },
                        // Lower platforms
                        { x: 250, y: 450, width: 200, height: 150, type: 'grass' },
                        // Moving platforms (lifts)
                        { x: 480, y: 400, width: 100, height: 20, type: 'stone', moving: 'vertical', moveDist: 180, moveSpeed: 1.5 },
                        { x: 180, y: 350, width: 100, height: 20, type: 'stone', moving: 'vertical', moveDist: 180, moveSpeed: 1.5, offset: 1.5 }, // Offset animation
                     ],
                     spikes: [
                        // Top row spikes
                        { x: 250, y: 185, width: 200, type: 'up' },
                        // Bottom row spikes
                        { x: 250, y: 435, width: 200, type: 'up' },
                     ],
                     hazards: [], checkpoints: [{x: 300, y: 420 }], buttons: [], triggerables: [],
                     hints: [ { text: "Danger!", x: 300, y: 300} ]
                 },
                 // Level 4: Axes (Simplified)
                 {
                    name: "Level 4: Axes", brief: "🚩 Watch out!", playerStart: { x: 50, y: 400 }, goal: { x: 750, y: 480 },
                    platforms: [
                        { x: 0, y: 450, width: 600, height: 150, type: 'grass' },
                        { x: 500, y: 300, width: 150, height: 20, type: 'wood' }, // Upper small platforms
                        { x: 300, y: 300, width: 150, height: 20, type: 'wood' },
                        { x: 100, y: 300, width: 150, height: 20, type: 'wood' },
                        { x: 600, y: 450, width: 150, height: 150, type: 'stairs' }, // Stairs
                        { x: 800, y: 450, width: 200, height: 150, type: 'grass' },
                        { x: 1050, y: 450, width: 200, height: 150, type: 'grass' },
                        { x: 1300, y: 500, width: 200, height: 100, type: 'grass' }, // Goal plat
                    ],
                    spikes: [],
                    hazards: [
                        { type: 'stomper', x: 150, y: 320, width: 50, height: 80, speed: 1 },
                        { type: 'stomper', x: 350, y: 320, width: 50, height: 80, speed: 1.2, offset: 0.5 },
                        { type: 'stomper', x: 550, y: 320, width: 50, height: 80, speed: 0.8, offset: 1.0 },
                        { type: 'swinging_axe', x: 1150, y: 300, size: 50, speed: 1.5 },
                        { type: 'swinging_axe', x: 1350, y: 300, size: 50, speed: 1.5, offset: Math.PI } // Opposite swing
                    ],
                    checkpoints: [{x: 700, y: 270 }], buttons: [], triggerables: [],
                    hints: [ { text: "?", x: 850, y: 400 }, { text: "Axes! =)", x: 1100, y: 400 } ]
                 },
                // Add placeholders for remaining levels
                 { name: "Level 5: Jump!", brief: "🚩 Use the see-saw", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 100 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 6: Springboards", brief: "🚩 Boing!", playerStart: { x: 50, y: 100 }, goal: { x: 700, y: 400 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 7: Box bridge", brief: "🚩 Push the box", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 150 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 8: Car", brief: "🚗 Vroom!", playerStart: { x: 50, y: 100 }, goal: { x: 700, y: 400 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 9: Ninja on the bridge", brief: "🚩 Bouncy bridge", playerStart: { x: 50, y: 100 }, goal: { x: 700, y: 400 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 10: Red ball on the ball", brief: "🚩 Balance!", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 400 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 11: Train", brief: "🚂 All aboard!", playerStart: { x: 50, y: 400 }, goal: { x: 1500, y: 400 }, platforms: [{ x: 0, y: 450, width: 1600, height: 150, type: 'track' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 12: Last level", brief: "🚩 Almost there!", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 100 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 13: Pakman", brief: "👹 Chomp!", playerStart: { x: 50, y: 300 }, goal: { x: 700, y: 100 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 14: Catapult", brief: "🚩 Fling!", playerStart: { x: 50, y: 400 }, goal: { x: 700, y: 100 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 15: Shop burglary", brief: "🛒 Heist!", playerStart: { x: 50, y: 300 }, goal: { x: 700, y: 100 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 16: Short cut", brief: "🚩 Secret path?", playerStart: { x: 50, y: 100 }, goal: { x: 50, y: 350 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'grass' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
                 { name: "Level 17: The King", brief: "⭐ The End?", playerStart: { x: 100, y: 100 }, goal: { x: 700, y: 100 }, platforms: [{ x: 0, y: 450, width: 800, height: 150, type: 'star' }], spikes: [], hazards: [], checkpoints: [], buttons: [], triggerables: [], hints: [] },
            ],
            levelElements: [], // Store DOM elements for the current level


            init() {
                this.loadProgress();
                this.setupEventListeners();
                this.populateLevelSelect();
                this.showScreen('main-menu'); // Start at the main menu
                console.log("Game Initialized");
            },

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                     // Prevent default browser scrolling for arrow keys and space
                     if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
                         e.preventDefault();
                     }

                    if (this.currentScreen === 'game' && !this.isPaused) {
                        if (e.key.toLowerCase() === 'r') this.restartLevel();
                        if (e.key.toLowerCase() === 'p') this.togglePause();
                    }
                    if (this.currentScreen === 'game' && e.key === 'Escape') {
                       e.preventDefault(); // Prevent Esc from exiting fullscreen etc.
                       this.quitLevel();
                    }
                     if (this.currentScreen === 'pause' && e.key.toLowerCase() === 'p') {
                        this.togglePause(); // Unpause with P as well
                     }
                      if (this.currentScreen === 'pause' && e.key === 'Escape') {
                         this.quitLevel(); // Quit from pause menu
                      }
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            },

            showScreen(screenId) {
                this.currentScreen = screenId;
                Object.values(this.screens).forEach(screen => {
                    screen.style.display = 'none';
                });
                if (this.screens[screenId]) {
                    this.screens[screenId].style.display = 'flex';
                } else {
                    console.error("Screen not found:", screenId);
                }
                // If switching to game screen, ensure pause overlay is hidden
                if (screenId === 'game') {
                    this.screens.pause.style.display = 'none';
                }
                 console.log("Showing screen:", screenId);
            },

            populateLevelSelect() {
                 this.levelGrid.innerHTML = ''; // Clear existing buttons
                 this.levelData.forEach((level, index) => {
                     const button = document.createElement('button');
                     button.classList.add('level-button');
                     button.textContent = index + 1;
                     if (index > this.maxUnlockedLevel) {
                         button.classList.add('locked');
                         button.disabled = true;
                         button.title = "Locked";
                     } else {
                         button.onclick = () => this.loadLevel(index);
                         button.onmouseover = () => this.showLevelPreview(index);
                         button.onmouseout = () => this.clearLevelPreview();
                          button.title = level.name;
                     }
                     this.levelGrid.appendChild(button);
                 });
             },

             showLevelPreview(index) {
                if (index <= this.maxUnlockedLevel) {
                    const level = this.levelData[index];
                    this.levelPreviewInfo.textContent = `${level.name}: ${level.brief || 'No description'}`;
                    // Basic preview rendering (just a goal flag for now)
                    this.levelPreview.innerHTML = `<div class="goal" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);">${level.brief.includes('🚩') ? '🚩' : level.brief.includes('🚗') ? '🚗' : level.brief.includes('⭐') ? '⭐' : '❓'}</div>`;
                } else {
                    this.levelPreviewInfo.textContent = `Level ${index + 1} (Locked)`;
                     this.levelPreview.innerHTML = '';
                }
            },

            clearLevelPreview() {
                 this.levelPreviewInfo.textContent = "Select the level you want to play!";
                 this.levelPreview.innerHTML = '';
             },


            startGame() {
                this.populateLevelSelect(); // Ensure level select is up-to-date
                this.showScreen('levelSelect');
            },

            loadLevel(levelIndex) {
                console.log("Loading level:", levelIndex);
                 if (levelIndex >= this.levelData.length || levelIndex < 0) {
                     console.error("Invalid level index:", levelIndex);
                     this.showScreen('levelSelect'); // Go back to level select if invalid
                     return;
                 }
                 this.currentLevelIndex = levelIndex;
                 const level = this.levelData[levelIndex];
                 this.levelTitleElement.textContent = level.name;

                // Clear previous level elements
                this.world.innerHTML = ''; // Clear everything except the player template if needed
                this.levelElements = []; // Reset level elements array

                 // Reset player position and velocity based on level data
                 this.player.x = level.playerStart.x;
                 this.player.y = level.playerStart.y;
                 this.player.vx = 0;
                 this.player.vy = 0;
                 this.player.onGround = false;
                 this.player.hasCar = level.name.includes("Car"); // Check if it's a car level
                 this.player.carElement = null;

                // Add player element back to the world if it was removed
                 this.world.appendChild(this.playerElement);

                // Render static level elements (platforms, spikes, goal, etc.)
                this.renderLevel(level);

                // Start the game loop
                this.isPaused = false;
                this.screens.pause.style.display = 'none';
                 this.showScreen('game');
                 if (this.gameLoopId) cancelAnimationFrame(this.gameLoopId); // Clear any existing loop
                 this.gameLoopId = requestAnimationFrame(this.update.bind(this));
             },

             renderLevel(level) {
                 level.platforms?.forEach(p => this.createElement(p, 'platform'));
                 level.spikes?.forEach(s => this.createElement(s, 'spike'));
                 level.hazards?.forEach(h => this.createElement(h, 'hazard'));
                 level.checkpoints?.forEach(c => this.createElement(c, 'checkpoint'));
                 level.buttons?.forEach(b => this.createElement(b, 'button'));
                 level.triggerables?.forEach(t => this.createElement(t, 'triggerable'));
                 level.hints?.forEach(h => this.createElement(h, 'hint'));

                 // Goal
                  if (level.goal) {
                     this.createElement(level.goal, 'goal');
                 }

                 // Add player car if needed
                  if (this.player.hasCar) {
                      this.player.carElement = document.createElement('div');
                      this.player.carElement.classList.add('game-object', 'car');
                      this.player.carElement.style.width = '60px';
                      this.player.carElement.style.height = '35px';
                      const carBody = document.createElement('div');
                      carBody.classList.add('car-body');
                      this.player.carElement.appendChild(carBody);
                      this.world.appendChild(this.player.carElement);
                      this.levelElements.push({ element: this.player.carElement, type: 'car', ...this.player }); // Add car to elements for rendering
                  }
             },

             createElement(data, type) {
                const el = document.createElement('div');
                el.classList.add('game-object');
                let elementData = { element: el, type: type, ...data }; // Store original data with element

                 switch (type) {
                    case 'platform':
                         el.classList.add('platform');
                         if (data.type === 'stone') el.classList.add('stone-platform');
                         if (data.type === 'brick') el.classList.add('brick-platform');
                         if (data.type === 'wood') { el.style.backgroundColor = '#deb887'; el.style.borderTopColor = '#8b4513'; }
                         if (data.type === 'stairs') { /* Add styling for stairs if needed */ el.style.backgroundColor = '#A0522D'; el.style.borderTop = 'none';} // Basic brown
                         if (data.type === 'track') {el.style.backgroundColor = '#696969'; el.style.borderTop = '3px solid #444';} // Simple track
                         if (data.type === 'star') {el.style.background = 'gold'; el.textContent = '⭐'; el.style.fontSize=`${data.width}px`; el.style.border='none'; el.style.display='flex'; el.style.justifyContent='center'; el.style.alignItems='center'; el.style.color = 'darkorange'; el.style.textShadow='1px 1px black';} // Placeholder star


                         el.style.left = `${data.x}px`;
                         el.style.top = `${data.y}px`;
                         el.style.width = `${data.width}px`;
                         el.style.height = `${data.height}px`;

                         if (data.moving === 'horizontal') {
                             el.classList.add('moving-platform');
                             el.style.animationDuration = `${4 / (data.moveSpeed || 1)}s`; // Adjust duration based on speed
                             el.style.setProperty('--move-distance', `${data.moveDist || 100}px`); // Custom property for distance if needed
                              el.style.animationDelay = `${data.offset || 0}s`;
                             // Add JS-based movement if CSS animation isn't sufficient
                         } else if (data.moving === 'vertical') {
                              el.classList.add('moving-platform-vertical');
                              el.style.animationDuration = `${3 / (data.moveSpeed || 1)}s`;
                              el.style.setProperty('--move-distance-y', `${data.moveDist || 80}px`);
                              el.style.animationDelay = `${data.offset || 0}s`;
                         }
                         break;
                     case 'spike':
                         el.classList.add('spike');
                         el.style.left = `${data.x}px`;
                         el.style.top = `${data.y}px`;
                         if(data.type === 'down') el.classList.add('spike-up'); // Assuming 'up' means pointing up from ground
                         if(data.type === 'left') el.classList.add('spike-left');
                         if(data.type === 'right') el.classList.add('spike-right');
                          // Handle multi-spikes
                          if (data.width) {
                              el.style.width = `${data.width}px`;
                              el.style.height = `15px`; // Height of a single spike
                              el.style.border = 'none'; // Remove single spike border
                              el.style.display = 'flex';
                              const numSpikes = Math.floor(data.width / 20); // 20px per spike approx
                              for(let i=0; i<numSpikes; i++) {
                                  const s = document.createElement('div');
                                   s.style.width = '0'; s.style.height = '0';
                                   s.style.borderLeft = '10px solid transparent';
                                   s.style.borderRight = '10px solid transparent';
                                  if (data.type === 'down') { // Pointing down
                                      s.style.borderTop = '15px solid red';
                                  } else { // Pointing up (default)
                                       s.style.borderBottom = '15px solid red';
                                  }
                                   el.appendChild(s);
                              }
                          }

                         break;
                     case 'goal':
                     case 'checkpoint':
                          el.classList.add('goal'); // Use goal styling for checkpoints too
                          el.textContent = '🚩';
                          el.style.left = `${data.x}px`;
                          el.style.top = `${data.y}px`;
                          el.style.width = `30px`; // Set explicit size for collision
                          el.style.height = `30px`;
                         break;
                      case 'hazard':
                          el.classList.add('hazard');
                          if (data.type === 'pendulum') {
                               el.classList.add('pendulum');
                               el.style.left = `${data.x}px`;
                               el.style.top = `${data.y}px`;
                               el.style.width = `${data.width}px`;
                               el.style.height = `${data.height}px`;
                               const rope = document.createElement('div');
                               rope.classList.add('pendulum-rope');
                               rope.style.height = `${data.ropeLength || 100}px`;
                               rope.style.top = `-${data.ropeLength || 100}px`;
                               el.appendChild(rope);
                          } else if (data.type === 'ramp') {
                              el.style.left = `${data.x}px`;
                              el.style.top = `${data.y}px`;
                              el.style.width = '0';
                              el.style.height = '0';
                              el.style.borderBottom = `${data.height}px solid #8B4513`;
                              el.style.borderLeft = `${data.width}px solid transparent`;
                              elementData.isRamp = true; // Mark for collision handling
                          } else if (data.type === 'stomper') {
                              el.style.left = `${data.x}px`;
                              el.style.top = `${data.y - 200}px`; // Start high up
                              el.style.width = `${data.width}px`;
                              el.style.height = `${data.height}px`;
                              el.style.background = 'grey';
                              el.innerHTML = `<div style="width:100%; height:15px; background:red; position:absolute; bottom:0; border-top: 2px solid darkred;"></div>`; // Red spike tip
                               // Simple JS animation for stomper
                              el.dataset.startY = data.y;
                              el.dataset.speed = data.speed || 1;
                              el.dataset.offset = data.offset || 0;
                              el.dataset.direction = 1; // 1 = down, -1 = up
                              el.dataset.waitTimer = data.offset * 60; // Offset start
                          } else if (data.type === 'swinging_axe') {
                               el.style.left = `${data.x}px`;
                               el.style.top = `${data.y}px`;
                               el.style.width = `${data.size}px`;
                               el.style.height = `${data.size*1.5}px`; // Axe shape
                               el.style.fontSize = `${data.size}px`;
                               el.textContent = '🪓';
                               el.style.transformOrigin = 'top center';
                               el.style.animation = `swing ${3 / (data.speed || 1)}s ease-in-out infinite alternate`;
                               el.style.animationDelay = `${(data.offset / Math.PI) * (1.5 / (data.speed || 1))}s`; // Attempt delay based on offset
                          }
                         // Add other hazard types here (rotating spikes, pacman etc.)
                         break;
                    case 'button':
                         el.classList.add('button');
                         if(data.color === 'green') el.classList.add('green');
                         el.style.left = `${data.x}px`;
                         el.style.top = `${data.y}px`;
                         el.dataset.targetId = data.targetId;
                         el.onclick = () => this.pressButton(elementData); // Allow clicking for debug
                         break;
                    case 'triggerable':
                         el.id = data.id; // Assign ID for targeting
                         el.classList.add('triggerable');
                         // Assume it's a platform for now
                         el.classList.add('platform');
                          if (data.type === 'stone') el.classList.add('stone-platform');
                          if (data.type === 'brick') el.classList.add('brick-platform');
                          el.style.left = `${data.x}px`;
                          el.style.top = `${data.y}px`;
                          el.style.width = `${data.width}px`;
                          el.style.height = `${data.height}px`;
                          if(data.hiddenByDefault) el.classList.add('hidden');
                         break;
                      case 'hint':
                          el.classList.add('hint');
                          el.style.position = 'absolute';
                          el.style.left = `${data.x}px`;
                          el.style.top = `${data.y}px`;
                          el.style.color = 'white';
                          el.style.fontSize = '14px';
                          el.style.textShadow = '1px 1px black';
                          el.style.background = 'rgba(0,0,0,0.4)';
                          el.style.padding = '2px 5px';
                          el.style.borderRadius = '3px';
                          el.textContent = data.text;
                          el.style.zIndex = 50; // Ensure hints are visible
                         break;

                }
                 this.world.appendChild(el);
                 this.levelElements.push(elementData);
             },

             pressButton(buttonData) {
                 if (!buttonData.element.classList.contains('pressed')) {
                     buttonData.element.classList.add('pressed');
                     const targetElement = this.levelElements.find(el => el.id === buttonData.targetId && el.type === 'triggerable');
                     if (targetElement) {
                         targetElement.element.classList.toggle('hidden'); // Toggle visibility/state
                         console.log(`Button ${buttonData.x},${buttonData.y} triggered ${buttonData.targetId}`);
                     }
                     // Optional: Reset button after a delay
                     // setTimeout(() => buttonData.element.classList.remove('pressed'), 500);
                 }
             },

             update() {
                 if (this.isPaused) {
                     this.gameLoopId = requestAnimationFrame(this.update.bind(this));
                     return;
                 }

                 const level = this.levelData[this.currentLevelIndex];

                 // --- Input ---
                 let targetVx = 0;
                 if (this.keys['arrowleft'] || this.keys['a']) {
                     targetVx = -this.moveSpeed;
                 }
                 if (this.keys['arrowright'] || this.keys['d']) {
                     targetVx = this.moveSpeed;
                 }
                 // Smooth acceleration/deceleration
                 this.player.vx += (targetVx - this.player.vx) * 0.3;


                 // --- Jumping ---
                  if ((this.keys['arrowup'] || this.keys['w'] || this.keys[' ']) && this.player.onGround) {
                     this.player.vy = this.jumpPower;
                     this.player.onGround = false;
                 }

                 // --- Physics ---
                 // Apply friction if on ground and not actively moving
                 if (this.player.onGround && targetVx === 0) {
                     this.player.vx *= this.friction;
                 }
                  // Apply gravity
                 this.player.vy += this.gravity;
                  // Clamp fall speed
                  if (this.player.vy > this.maxFallSpeed) {
                     this.player.vy = this.maxFallSpeed;
                  }


                  // --- Collision Detection & Resolution (Simplified) ---
                  this.player.onGround = false; // Assume not on ground until collision check
                  let potentialY = this.player.y + this.player.vy;
                  let potentialX = this.player.x + this.player.vx;

                   // Pre-calculate player bounds for collision checks
                   const playerRect = {
                       x: potentialX,
                       y: potentialY,
                       width: this.player.width,
                       height: this.player.height
                   };

                 this.levelElements.forEach(obj => {
                     if (!obj.element || obj.element.classList.contains('hidden')) return; // Skip hidden elements

                      const objRect = obj.element.getBoundingClientRect();
                      const worldRect = this.world.getBoundingClientRect();
                      // Adjust object rect to be relative to the game world
                      const staticObjRect = {
                          x: objRect.left - worldRect.left,
                          y: objRect.top - worldRect.top,
                          width: objRect.width,
                          height: objRect.height,
                          type: obj.type, // Pass type for specific collision logic
                          element: obj.element, // Pass element for interactions
                          data: obj // Pass original data
                      };

                       // --- Animate Hazards (Example: Stomper) ---
                       if (obj.type === 'hazard' && obj.data.type === 'stomper') {
                           if (obj.element.dataset.waitTimer > 0) {
                               obj.element.dataset.waitTimer--;
                           } else {
                               let stomperY = parseFloat(obj.element.style.top || obj.data.y);
                               const startY = parseFloat(obj.element.dataset.startY);
                               const speed = parseFloat(obj.element.dataset.speed);
                               let direction = parseInt(obj.element.dataset.direction);

                               stomperY += speed * direction;

                               if (direction === 1 && stomperY >= startY) { // Moving down, hit bottom
                                   stomperY = startY;
                                   obj.element.dataset.direction = -1; // Move up
                                   obj.element.dataset.waitTimer = 30; // Wait at bottom
                               } else if (direction === -1 && stomperY <= startY - 150) { // Moving up, hit top (adjust range)
                                   stomperY = startY - 150;
                                   obj.element.dataset.direction = 1; // Move down
                                   obj.element.dataset.waitTimer = 60; // Wait at top
                               }
                               obj.element.style.top = `${stomperY}px`;
                                // Update staticObjRect for collision as it moves
                               staticObjRect.y = stomperY;
                           }
                       }


                       // --- Broad Phase (Simple Check) ---
                       // A simple distance check could optimize, but skip for now

                       // --- Narrow Phase (AABB Collision) ---
                       if (this.checkCollision(playerRect, staticObjRect)) {
                           // --- Specific Collision Responses ---
                            if (obj.type === 'goal') {
                               this.levelComplete();
                               return; // Stop further processing for this frame
                           } else if (obj.type === 'checkpoint') {
                               // Update spawn point logic if implemented
                               console.log("Checkpoint reached!");
                               obj.element.style.opacity = '0.5'; // Visually indicate activation
                               // Ideally, save checkpoint state here
                           } else if (obj.type === 'spike' || (obj.type === 'hazard' && (obj.data.type === 'pendulum' || obj.data.type === 'stomper' || obj.data.type === 'swinging_axe'))) {
                                this.restartLevel();
                                return;
                           } else if (obj.type === 'button') {
                                this.pressButton(obj); // Trigger button on collision
                           }


                           // --- Platform Collision Resolution ---
                           if (obj.type === 'platform' || obj.type === 'triggerable' || (obj.type === 'hazard' && obj.data.isRamp)) { // Treat triggerables and ramps as platforms
                                // Check collision from vertical movement
                                const prevPlayerRectY = { ...playerRect, y: this.player.y }; // Player rect before vertical move
                                if (this.player.vy > 0 && !this.checkCollision(prevPlayerRectY, staticObjRect)) { // Moving down and wasn't colliding before
                                    // Landed on top
                                    this.player.vy = 0;
                                    potentialY = staticObjRect.y - this.player.height;
                                    this.player.onGround = true;

                                    // Handle moving platforms - match horizontal speed (basic)
                                     if(obj.data.moving === 'horizontal') {
                                         // This needs a proper physics engine integration for accuracy
                                         // Basic approach: add platform speed. Issues: requires knowing platform velocity.
                                         // Let's rely on player input mostly for now.
                                     }
                                      if(obj.data.moving === 'vertical') {
                                           // Stick player to vertical platform (basic)
                                           potentialY += parseFloat(obj.element.style.animationDirection === 'alternate' ? (Math.sin(Date.now() / (1500 / (obj.data.moveSpeed || 1))) * (obj.data.moveDist || 80)/2) : 0); // approximation needed
                                      }


                                } else {
                                     // Check collision from horizontal movement
                                     const prevPlayerRectX = { ...playerRect, x: this.player.x }; // Player rect before horizontal move
                                     if (!this.checkCollision(prevPlayerRectX, staticObjRect)) { // Wasn't colliding before horizontal move
                                         if (this.player.vx > 0) { // Moving right
                                             this.player.vx = 0;
                                             potentialX = staticObjRect.x - this.player.width;
                                         } else if (this.player.vx < 0) { // Moving left
                                             this.player.vx = 0;
                                             potentialX = staticObjRect.x + staticObjRect.width;
                                         }
                                     } else {
                                          // Player might be inside - check bottom collision (hitting head)
                                          if (this.player.vy < 0 && playerRect.y < staticObjRect.y + staticObjRect.height && this.player.y >= staticObjRect.y + staticObjRect.height) {
                                                this.player.vy = 0;
                                                potentialY = staticObjRect.y + staticObjRect.height;
                                          }
                                          // Might need more robust resolution if stuck inside
                                     }
                                }
                           }
                       }
                 });

                // Update player position
                this.player.x = potentialX;
                this.player.y = potentialY;


                 // --- Boundary Checks ---
                 if (this.player.x < 0) this.player.x = 0;
                 if (this.player.x + this.player.width > this.container.clientWidth) { // Use game container width for level bounds
                     this.player.x = this.container.clientWidth - this.player.width;
                 }
                 // Fall out of bounds check
                 if (this.player.y > this.container.clientHeight) {
                     this.restartLevel();
                     return; // Stop this frame
                 }

                 // --- Render ---
                 this.playerElement.style.left = `${this.player.x}px`;
                 this.playerElement.style.top = `${this.player.y}px`;
                 // Update car position if applicable
                  if (this.player.hasCar && this.player.carElement) {
                       this.player.carElement.style.left = `${this.player.x - 15}px`; // Center car approx
                       this.player.carElement.style.top = `${this.player.y - 5}px`; // Position car under ball
                  }


                 // --- Continue Loop ---
                 this.gameLoopId = requestAnimationFrame(this.update.bind(this));
             },

             checkCollision(rect1, rect2) {
                 return (
                     rect1.x < rect2.x + rect2.width &&
                     rect1.x + rect1.width > rect2.x &&
                     rect1.y < rect2.y + rect2.height &&
                     rect1.y + rect1.height > rect2.y
                 );
             },

             levelComplete() {
                 console.log(`Level ${this.currentLevelIndex + 1} Complete!`);
                 alert(`Level ${this.currentLevelIndex + 1} Complete!`);
                 this.maxUnlockedLevel = Math.max(this.maxUnlockedLevel, this.currentLevelIndex + 1);
                 this.saveProgress();
                 // Stop the current game loop
                  if (this.gameLoopId) {
                     cancelAnimationFrame(this.gameLoopId);
                     this.gameLoopId = null;
                 }
                 // Check if there's a next level
                 if (this.currentLevelIndex + 1 < this.levelData.length) {
                      this.loadLevel(this.currentLevelIndex + 1);
                 } else {
                     alert("Congratulations! You beat all levels!");
                     this.showScreen('levelSelect'); // Go back to level select
                 }
             },

             restartLevel() {
                console.log("Restarting Level");
                 if (this.gameLoopId) cancelAnimationFrame(this.gameLoopId); // Stop loop before reloading
                 this.loadLevel(this.currentLevelIndex);
             },

             skipLevel() {
                 console.log("Skipping Level");
                 if (this.gameLoopId) cancelAnimationFrame(this.gameLoopId);
                 this.maxUnlockedLevel = Math.max(this.maxUnlockedLevel, this.currentLevelIndex + 1); // Unlock next level
                 this.saveProgress();
                  if (this.currentLevelIndex + 1 < this.levelData.length) {
                     this.loadLevel(this.currentLevelIndex + 1);
                 } else {
                      alert("You skipped the last level!");
                      this.showScreen('levelSelect');
                 }
              },


             quitLevel() {
                 console.log("Quitting Level");
                  if (this.gameLoopId) {
                     cancelAnimationFrame(this.gameLoopId);
                     this.gameLoopId = null;
                 }
                 this.isPaused = false; // Ensure not paused when quitting
                 this.populateLevelSelect(); // Update locked status
                 this.showScreen('levelSelect');
             },

             togglePause() {
                 this.isPaused = !this.isPaused;
                 if (this.isPaused) {
                     this.screens.pause.style.display = 'flex';
                      // No need to cancel animation frame here, the update loop handles the pause flag
                      console.log("Game Paused");
                 } else {
                     this.screens.pause.style.display = 'none';
                     // Restart the loop ONLY if it was completely stopped (it shouldn't be with this flag approach)
                     // if (!this.gameLoopId) {
                     //     this.gameLoopId = requestAnimationFrame(this.update.bind(this));
                     // }
                      console.log("Game Resumed");
                 }
             },

             saveProgress() {
                try {
                    localStorage.setItem('redBallMaxLevel', this.maxUnlockedLevel);
                } catch (e) {
                    console.warn("Could not save progress to localStorage:", e);
                }
            },

            loadProgress() {
                try {
                    const savedLevel = localStorage.getItem('redBallMaxLevel');
                    if (savedLevel !== null) {
                        this.maxUnlockedLevel = parseInt(savedLevel, 10);
                    }
                } catch (e) {
                     console.warn("Could not load progress from localStorage:", e);
                }
            }


        };

        // Initialize the game when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => game.init());

    </script>

</body>
</html>