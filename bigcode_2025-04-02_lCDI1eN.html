<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Ball Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
            overflow: hidden; /* Prevent scrolling */
        }
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background-color: lightblue; /* Default sky */
            overflow: hidden;
            border: 5px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            display: block;
            background-color: transparent; /* Canvas draws over the container background */
            position: absolute;
            top: 0;
            left: 0;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent overlay */
            color: white;
            text-align: center;
            z-index: 10;
            visibility: hidden; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .screen.active {
            visibility: visible;
            opacity: 1;
        }
         /* Specific Screen Backgrounds */
        #main-menu { background: linear-gradient(to bottom, #87CEEB, #ADD8E6); /* Sky Blue Gradient */ }
        #settings-menu { background-color: #90EE90; /* Light Green */ }
        #level-select { background: linear-gradient(to bottom, #87CEEB, #90EE90); /* Sky to Grass */ }

        /* --- UI Elements --- */
        .game-title {
            font-size: 72px;
            color: #FF4136; /* Red */
            text-shadow: 4px 4px 0 #8B0000, /* Dark Red Shadow */
                         -2px -2px 0 white,
                         2px -2px 0 white,
                         -2px 2px 0 white,
                         2px 2px 0 white;
            margin-bottom: 40px;
            font-weight: bold;
        }

        .button {
            background-color: #FF4136; /* Red */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px; /* Rounded pill shape */
            font-size: 24px;
            cursor: pointer;
            margin: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: background-color 0.2s, transform 0.1s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .button:hover {
            background-color: #E13025; /* Darker Red */
        }
         .button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 3px rgba(0,0,0,0.2);
        }

        .icon-button {
             background-color: #FF4136;
             border-radius: 50%;
             width: 60px;
             height: 60px;
             padding: 0;
             font-size: 30px; /* Adjust icon size */
             line-height: 60px; /* Center icon vertically */
             box-shadow: 0 3px 5px rgba(0,0,0,0.3);
        }
         .icon-button.small {
            width: 50px;
            height: 50px;
            font-size: 24px;
            line-height: 50px;
        }
        .icon-button:active {
             transform: scale(0.9);
             box-shadow: 0 1px 2px rgba(0,0,0,0.2);
         }

        #main-menu-buttons {
            position: absolute;
            bottom: 150px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
         #main-menu-play {
            width: 100px;
            height: 100px;
            font-size: 50px;
            margin: 0 20px;
        }
        #main-menu-settings {
             position: absolute;
             bottom: 50px;
             left: 50%;
             transform: translateX(-50%);
        }

        #settings-menu .setting-row {
            font-size: 30px;
            margin: 15px 0;
            color: #8B0000; /* Dark Red Text */
            font-weight: bold;
            text-shadow: 1px 1px 0 white;
        }
        #settings-menu .setting-row span {
            display: inline-block;
            width: 100px; /* Align ON/OFF */
            font-weight: normal;
            cursor: pointer;
        }
        #settings-back-button {
            position: absolute;
            bottom: 30px;
            left: 30px;
        }

        #level-select h2 {
             font-size: 40px;
             color: white;
             text-shadow: 2px 2px 0 #555;
             margin-bottom: 20px;
        }
        #level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        .level-button {
            width: 70px;
            height: 70px;
            font-size: 30px;
            line-height: 70px;
            background-color: #FF851B; /* Orange */
            border: 3px solid white;
            position: relative; /* For coin overlay */
        }
        .level-button:hover {
            background-color: #E6700B; /* Darker Orange */
        }
        .level-coin { /* Placeholder for earned coins/stars */
            position: absolute;
            bottom: -5px;
            right: -5px;
            font-size: 20px;
        }

        #level-select-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }
        #level-select-navigation .nav-arrow {
            font-size: 40px;
            margin: 0 20px;
        }
        #level-select-pagination {
            display: flex;
            gap: 8px;
        }
        .pagination-dot {
            width: 15px;
            height: 15px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            border: 1px solid #555;
        }
        .pagination-dot.active {
            background-color: #FF851B; /* Orange */
        }
        #level-select-back-button {
            position: absolute;
            bottom: 30px;
            left: 30px;
        }


         #pause-menu-content, #game-over-content {
             background-color: rgba(50, 50, 50, 0.85);
             padding: 30px 50px;
             border-radius: 20px;
             border: 3px solid white;
             display: flex;
             gap: 15px;
             align-items: center;
         }
          #game-over-content {
              flex-direction: column;
          }
          #game-over-content h2 {
              font-size: 40px;
              margin-bottom: 10px;
              color: #FF4136;
              text-shadow: 1px 1px 1px black;
          }
          #game-over-content .button {
              background-color: #FFDC00; /* Yellow */
              color: #8B4513; /* Brown */
              font-weight: bold;
          }
           #game-over-content .button:hover {
               background-color: #ECCB00;
           }


        /* In-Game UI (Drawn on Canvas, styles here are indicative) */
        .hud-element {
             position: absolute;
             color: white;
             font-size: 24px;
             font-weight: bold;
             text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
             z-index: 5;
         }
         #hud-lives { top: 10px; left: 10px; font-size: 30px; }
         #hud-level { top: 10px; left: 50%; transform: translateX(-50%); }
         #hud-score-bar {
             top: 15px;
             right: 40px; /* Make space for pause */
             width: 150px;
             height: 20px;
             background-color: rgba(0, 0, 0, 0.3);
             border-radius: 10px;
             border: 1px solid white;
             overflow: hidden;
         }
         #hud-score-fill {
             width: 0%; /* Controlled by JS */
             height: 100%;
             background-color: #FFDC00; /* Yellow */
             border-radius: 10px;
             transition: width 0.2s linear;
         }
         #hud-score-icon { top: 10px; right: 195px; font-size: 25px; } /* Coin emoji */
         #hud-pause-button { top: 10px; right: 10px; font-size: 25px; cursor: pointer; padding: 5px; background-color: rgba(0,0,0,0.2); border-radius: 5px;}


         /* --- Animated Elements --- */
         .character {
             position: absolute;
             z-index: 2;
             /* Add animations if needed */
         }
         #main-menu-player {
             bottom: 50px;
             left: 50px;
             width: 100px;
             height: 100px;
             background-color: #FF4136; /* Red */
             border-radius: 50%;
             border: 4px solid black;
             display: flex;
             justify-content: center;
             align-items: center;
         }
          #main-menu-player::before, #main-menu-player::after { /* Eyes */
             content: '';
             position: absolute;
             width: 20px;
             height: 30px;
             background-color: white;
             border: 2px solid black;
             border-radius: 50%;
             top: 25px;
         }
          #main-menu-player::before { left: 20px; transform: rotate(-10deg); }
          #main-menu-player::after { right: 20px; transform: rotate(10deg); }
          /* Pupils */
          #main-menu-player span {
              position: absolute;
              width: 8px;
              height: 12px;
              background-color: black;
              border-radius: 50%;
              top: 35px;
          }
          #main-menu-player span:first-of-type { left: 28px; }
          #main-menu-player span:last-of-type { right: 28px; }


         #main-menu-enemy {
             bottom: 50px;
             right: 50px;
             width: 100px;
             height: 100px;
             background-color: #555; /* Dark Gray */
             border: 4px solid black;
             border-radius: 10px; /* Square */
              display: flex;
              justify-content: center;
              align-items: center;
              position: relative;
         }
          /* Enemy Eyes */
          #main-menu-enemy::before, #main-menu-enemy::after {
              content: '';
              position: absolute;
              width: 25px;
              height: 20px;
              background-color: #FFDC00; /* Yellow */
              border: 2px solid black;
              border-radius: 40% 40% 0 0 / 80% 80% 0 0; /* Eyebrow shape */
              top: 20px;
          }
           #main-menu-enemy::before { left: 15px; transform: rotate(15deg); }
           #main-menu-enemy::after { right: 15px; transform: rotate(-15deg); }
           /* Enemy Pupils */
           #main-menu-enemy span {
               position: absolute;
               width: 8px;
               height: 12px;
               background-color: black;
               border-radius: 50%;
               top: 25px;
           }
           #main-menu-enemy span:first-of-type { left: 25px; }
           #main-menu-enemy span:last-of-type { right: 25px; }
            /* Enemy Mouth */
            #main-menu-enemy div {
                position: absolute;
                bottom: 10px;
                width: 70%;
                height: 25px;
                background-color: white;
                border: 2px solid black;
                border-radius: 5px 5px 10px 10px;
                display: flex;
                justify-content: space-around;
                align-items: flex-start;
                overflow: hidden;
            }
            /* Teeth */
            #main-menu-enemy div i {
                 width: 8px;
                 height: 12px;
                 background-color: white;
                 border-left: 2px solid black;
                 border-right: 2px solid black;
                 clip-path: polygon(50% 0%, 0% 100%, 100% 100%); /* Triangle */
                 margin-top: -2px;
            }

            /* Background elements for main menu */
            .bg-element { position: absolute; z-index: 1; }
            .bg-grass { bottom: 0; left: 0; width: 100%; height: 150px; background: linear-gradient(to bottom, #90EE90, #3CB371); border-top: 5px solid #2E8B57; }
            .bg-hill { bottom: 150px; width: 300px; height: 200px; background-color: #90EE90; border-radius: 50% 50% 0 0 / 100% 100% 0 0; border-top: 5px solid #2E8B57; }
            .bg-hill.left { left: -50px; }
            .bg-hill.right { right: -80px; width: 400px; height: 250px; }
            .bg-tree { bottom: 150px; width: 0; height: 0; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 60px solid #2E8B57; /* Green triangle */}
            .bg-tree.t1 { left: 150px; }
            .bg-tree.t2 { left: 200px; bottom: 180px; transform: scale(0.8); }
            .bg-tree.t3 { right: 250px; }
             .bg-windmill {
                bottom: 150px;
                right: 150px;
                width: 30px;
                height: 80px;
                background-color: #D2B48C; /* Tan */
                border: 2px solid #8B4513; /* Brown */
            }
             .bg-windmill::before { /* Roof */
                content: '';
                position: absolute;
                top: -20px;
                left: -17px;
                width: 0;
                height: 0;
                border-left: 32px solid transparent;
                border-right: 32px solid transparent;
                border-bottom: 20px solid #A0522D; /* Sienna */
            }
             .bg-windmill::after { /* Blades */
                 content: '+';
                 font-size: 80px;
                 color: #8B4513;
                 position: absolute;
                 top: -20px;
                 left: -25px;
                 transform-origin: center center;
                  animation: spin 10s linear infinite;
             }
              @keyframes spin {
                  from { transform: rotate(0deg); }
                  to { transform: rotate(360deg); }
              }


    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <!-- Main Menu Screen -->
        <div id="main-menu" class="screen active">
             <!-- Background elements -->
            <div class="bg-element bg-grass"></div>
            <div class="bg-element bg-hill left"></div>
            <div class="bg-element bg-hill right"></div>
            <div class="bg-element bg-tree t1"></div>
            <div class="bg-element bg-tree t2"></div>
             <div class="bg-element bg-windmill"></div>
            <div class="bg-element bg-tree t3"></div>


            <div class="game-title">RED BALL 4</div>
             <!-- Animated Characters -->
            <div id="main-menu-player" class="character"><span></span><span></span></div>
            <div id="main-menu-enemy" class="character">
                <span></span><span></span><div><i></i><i></i><i></i><i></i><i></i></div>
            </div>

            <div id="main-menu-buttons">
                <button id="main-menu-play" class="button icon-button">▶️</button>
            </div>
             <button id="main-menu-settings" class="button icon-button small">⚙️</button>

        </div>

        <!-- Settings Screen -->
        <div id="settings-menu" class="screen">
            <div class="game-title" style="font-size: 60px; margin-bottom: 50px;">SETTINGS</div>
            <div class="setting-row">MUSIC: <span id="setting-music">ON</span></div>
            <div class="setting-row">SOUND: <span id="setting-sound">ON</span></div>
            <div class="setting-row">LANGUAGE: <span id="setting-language">ENGLISH 🇺🇸</span></div>
            <button id="settings-back-button" class="button icon-button small">◀️</button>
        </div>

        <!-- Level Select Screen -->
        <div id="level-select" class="screen">
            <h2 id="world-title">1. GREEN HILLS</h2>
            <div id="level-grid">
                <!-- Level buttons will be generated by JS -->
            </div>
            <div id="level-select-navigation">
                <button id="world-prev" class="button icon-button small nav-arrow" disabled>&lt;</button>
                <div id="level-select-pagination">
                    <!-- Dots generated by JS -->
                </div>
                <button id="world-next" class="button icon-button small nav-arrow">&gt;</button>
            </div>
            <button id="level-select-back-button" class="button icon-button small">◀️</button>
        </div>

        <!-- Pause Screen -->
        <div id="pause-menu" class="screen">
            <div id="pause-menu-content">
                 <button id="pause-level-select" title="Level Select" class="button icon-button">⠿</button> <!-- Grid icon -->
                 <button id="pause-restart" title="Restart Level" class="button icon-button">🔄</button>
                 <button id="pause-sound" title="Toggle Sound" class="button icon-button">🔊</button>
                 <button id="pause-resume" title="Resume" class="button icon-button">▶️</button>
            </div>
        </div>

        <!-- Game Over / Restart Screen -->
         <div id="game-over-menu" class="screen">
              <div id="game-over-content">
                 <h2 id="game-over-title">TRY AGAIN?</h2> <!-- Or Level Complete! -->
                 <button id="game-over-restart" class="button">RESTART</button>
                 <button id="game-over-continue" class="button">CONTINUE ▶️</button> <!-- Or Next Level -->
                 <button id="game-over-menu-btn" class="button">MENU</button>
              </div>
         </div>

        <!-- In-Game HUD Elements (Managed by JS, placed here for structure) -->
        <div id="hud-lives" class="hud-element">❤️❤️❤️</div>
        <div id="hud-level" class="hud-element">LEVEL 01</div>
         <div id="hud-score-icon" class="hud-element">⭐</div>
        <div id="hud-score-bar" class="hud-element">
            <div id="hud-score-fill"></div>
        </div>
        <div id="hud-pause-button" class="hud-element">⏸️</div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');

        // Screens
        const mainMenuScreen = document.getElementById('main-menu');
        const settingsScreen = document.getElementById('settings-menu');
        const levelSelectScreen = document.getElementById('level-select');
        const pauseMenuScreen = document.getElementById('pause-menu');
        const gameOverMenuScreen = document.getElementById('game-over-menu');
        const hudElements = {
            lives: document.getElementById('hud-lives'),
            level: document.getElementById('hud-level'),
            scoreIcon: document.getElementById('hud-score-icon'),
            scoreBar: document.getElementById('hud-score-bar'),
            scoreFill: document.getElementById('hud-score-fill'),
            pauseBtn: document.getElementById('hud-pause-button')
        };

        let gameState = 'menu'; // menu, levelSelect, playing, paused, levelEnd, gameOver
        let currentLevelIndex = 0;
        let currentWorldIndex = 0; // 0: Green Hills
        let lives = 3;
        let score = 0;
        let totalStarsInLevel = 0;
        let isPaused = false;
        let gameLoopId = null;
        let levelCompleteStatus = false;

        // --- Game Settings ---
        let musicOn = true;
        let soundOn = true;
        const sounds = { // Basic sound placeholders
            jump: () => soundOn ? console.log('Sound: Jump') : null,
            stomp: () => soundOn ? console.log('Sound: Stomp') : null,
            star: () => soundOn ? console.log('Sound: Star') : null,
            death: () => soundOn ? console.log('Sound: Death') : null,
            flag: () => soundOn ? console.log('Sound: Flag') : null,
            click: () => soundOn ? console.log('Sound: Click') : null,
        };

        // --- Input Handling ---
        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            // Handle single press actions
            if (gameState === 'playing' && e.key.toLowerCase() === 'p') {
                togglePause();
            }
            if ((gameState === 'playing' || gameState === 'paused') && e.key.toLowerCase() === 'r') {
                restartLevel();
            }
        });

        // --- Player ---
        const player = {
            x: 100, y: 400, // Initial position (will be set by level)
            width: 30, height: 30,
            radius: 15,
            dx: 0, dy: 0, // velocities
            speed: 4,
            jumpPower: 11,
            gravity: 0.5,
            onGround: false,
            color: '#FF4136',
            eyes: [{offsetX: -5, offsetY: -4, pupilOffsetX: 0, pupilOffsetY: 0}, // Left eye
                   {offsetX: 5, offsetY: -4, pupilOffsetX: 0, pupilOffsetY: 0}] // Right eye
        };

        // --- Game Objects (Platforms, Enemies, Items) ---
        let platforms = [];
        let enemies = [];
        let stars = [];
        let hazards = []; // e.g., water
        let goals = []; // Flagpole
        let boxes = [];
        let boulders = [];
        let movingPlatforms = [];
        let seeSaws = [];
        let catapults = [];
        let waterWheels = [];
        // ... other dynamic objects

        // --- Simple Physics & Collision ---
        function applyGravity(obj) {
            if (!obj.onGround) {
                obj.dy += obj.gravity;
            }
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

         function checkCircleRectCollision(circle, rect) {
            let testX = circle.x;
            let testY = circle.y;

            if (circle.x < rect.x) testX = rect.x; // Left edge
            else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width; // Right edge
            if (circle.y < rect.y) testY = rect.y; // Top edge
            else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height; // Bottom edge

            const distX = circle.x - testX;
            const distY = circle.y - testY;
            const distance = Math.sqrt((distX * distX) + (distY * distY));

            return distance <= circle.radius;
        }

        function handleCollisions() {
            player.onGround = false;

            // Platforms
            platforms.forEach(p => {
                if (checkCircleRectCollision(player, p)) {
                    const playerBottom = player.y + player.radius;
                    const playerPrevBottom = (player.y - player.dy) + player.radius;
                    const platformTop = p.y;

                    // Landing on top?
                    if (player.dy > 0 && playerPrevBottom <= platformTop && playerBottom >= platformTop) {
                         player.y = platformTop - player.radius;
                         player.dy = 0;
                         player.onGround = true;
                    }
                    // Hitting from below?
                    else if (player.dy < 0 && (player.y - player.radius) >= (p.y + p.height - 5) && (player.y - player.radius + player.dy) < (p.y + p.height)) {
                        player.y = p.y + p.height + player.radius;
                        player.dy = 0.1; // Bounce down slightly
                    }
                     // Hitting side?
                     else if (playerBottom > p.y + 1 && (player.y - player.radius) < p.y + p.height -1) { // Check vertical overlap first
                         if (player.dx > 0 && (player.x + player.radius) >= p.x && (player.x - player.dx + player.radius) < p.x ) {
                             player.x = p.x - player.radius;
                             player.dx = 0;
                         } else if (player.dx < 0 && (player.x - player.radius) <= (p.x + p.width) && (player.x - player.dx - player.radius) > (p.x + p.width)) {
                            player.x = p.x + p.width + player.radius;
                            player.dx = 0;
                         }
                    }
                }
            });

             // Boxes (Simplified: treat like platforms for now)
             boxes.forEach(b => {
                 if (checkCircleRectCollision(player, b)) {
                    const playerBottom = player.y + player.radius;
                    const playerPrevBottom = (player.y - player.dy) + player.radius;
                    const boxTop = b.y;

                     // Landing on top?
                    if (player.dy > 0 && playerPrevBottom <= boxTop && playerBottom >= boxTop) {
                         player.y = boxTop - player.radius;
                         player.dy = 0;
                         player.onGround = true;
                     }
                     // Pushing? (Very basic horizontal push)
                     else if (playerBottom > b.y + 5 && (player.y - player.radius) < b.y + b.height - 5) {
                          if (player.dx !== 0 && ((player.x + player.radius > b.x && player.x < b.x) || (player.x - player.radius < b.x + b.width && player.x > b.x + b.width)) ) {
                             // Move box slightly - needs refinement for proper physics
                             b.x += player.dx * 0.5;
                             // Prevent player from entering box
                              if (player.dx > 0) player.x = b.x - player.radius - 1;
                              else player.x = b.x + b.width + player.radius + 1;
                             player.dx = 0;
                          }
                     }
                 }
             });

            // Enemies
            enemies.forEach((e, index) => {
                 if (checkCircleRectCollision(player, e)) {
                     const playerBottom = player.y + player.radius;
                     const playerPrevBottom = (player.y - player.dy) + player.radius;
                     const enemyTop = e.y;

                     // Stomp?
                     if (player.dy > 0.5 && playerPrevBottom <= enemyTop + 5) { // Small tolerance
                         console.log("Stomped enemy!");
                         sounds.stomp();
                         enemies.splice(index, 1); // Remove enemy
                         player.dy = -player.jumpPower * 0.6; // Small bounce
                         score += 50; // Example score
                     } else {
                         // Hit from side/bottom
                         handlePlayerDeath();
                     }
                 }
            });

            // Stars
            stars.forEach((s, index) => {
                 if (checkCircleRectCollision(player, s)) {
                     console.log("Collected star!");
                     sounds.star();
                     stars.splice(index, 1);
                     score += 100; // Example score
                     updateScoreBar();
                 }
            });

             // Hazards (Water)
             hazards.forEach(h => {
                 if (checkCircleRectCollision(player, h)) {
                     handlePlayerDeath();
                 }
             });

             // Goal
             goals.forEach(g => {
                  if (checkCircleRectCollision(player, g)) {
                     if (!levelCompleteStatus) {
                         handleLevelComplete();
                     }
                 }
             });

             // Keep player within bounds (simple)
             if (player.x - player.radius < 0) player.x = player.radius;
             if (player.x + player.radius > canvas.width) player.x = canvas.width - player.radius;
             if (player.y + player.radius > canvas.height + 50) { // Fall off bottom
                 handlePlayerDeath();
             }
        }

         function handlePlayerDeath() {
            console.log("Player Died!");
            sounds.death();
            lives--;
            updateLivesDisplay();
            if (lives <= 0) {
                 // Proper Game Over state could be added
                 console.log("Game Over (Restarting Level)");
                 lives = 3; // Reset lives for now
                 updateLivesDisplay();
                 restartLevel(); // Just restart level for this version
            } else {
                 resetPlayerPosition(); // Restart from checkpoint or beginning
            }
         }

         function handleLevelComplete() {
             console.log("Level Complete!");
             sounds.flag();
             gameState = 'levelEnd';
             levelCompleteStatus = true;
             player.dx = 0; // Stop movement
             player.dy = 0;
              document.getElementById('game-over-title').textContent = "LEVEL COMPLETE!";
              document.getElementById('game-over-continue').textContent = "NEXT LEVEL ▶️";
              document.getElementById('game-over-restart').style.display = 'none'; // Hide restart on complete
             setTimeout(() => {
                 showScreen(gameOverMenuScreen);
             }, 500); // Short delay before showing menu
         }


         function resetPlayerPosition() {
             // Find the start position for the current level
             const levelData = levels[currentWorldIndex][currentLevelIndex];
             player.x = levelData.playerStart.x;
             player.y = levelData.playerStart.y;
             player.dx = 0;
             player.dy = 0;
         }

         function restartLevel() {
             sounds.click();
             if (gameState === 'paused') togglePause(); // Unpause first
             console.log("Restarting Level", currentLevelIndex + 1);
             levelCompleteStatus = false; // Reset completion flag
             score = 0; // Reset score for the level? Or keep total? Reset for now.
             lives = 3; // Reset lives on full restart
             updateLivesDisplay();
             loadLevel(currentLevelIndex);
             gameState = 'playing';
              hideScreen(gameOverMenuScreen); // Ensure menus are hidden
         }


        // --- Level Loading ---
        const levels = [
             // World 0: Green Hills (Levels 1-10)
             [
                 // Level 1 (Index 0)
                 {
                     playerStart: { x: 50, y: 450 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)', // Sky
                     platforms: [
                         { x: 0, y: 500, width: 400, height: 100, color: '#2E8B57' }, // Ground left
                         { x: 450, y: 500, width: 350, height: 100, color: '#2E8B57' }, // Ground right
                         { x: 300, y: 450, width: 80, height: 20, color: '#A0522D' }, // Step 1
                         { x: 380, y: 400, width: 80, height: 20, color: '#A0522D' }, // Step 2
                         { x: 460, y: 450, width: 150, height: 20, color: '#A0522D' }, // Bridge
                     ],
                     enemies: [], stars: [{ x: 200, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 410, y: 370, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 750, y: 450, width: 10, height: 50, color: 'red' }], boxes:[], boulders:[]
                 },
                  // Level 2 (Index 1)
                 {
                     playerStart: { x: 50, y: 450 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                         { x: 0, y: 500, width: 200, height: 100, color: '#2E8B57' },
                         { x: 280, y: 500, width: 250, height: 100, color: '#2E8B57' },
                         { x: 600, y: 500, width: 200, height: 100, color: '#2E8B57' },
                     ],
                     enemies: [{ x: 650, y: 460, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 150, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 400, y: 400, width: 20, height: 20, color: 'yellow' }, { x: 700, y: 470, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 770, y: 450, width: 10, height: 50, color: 'red' }],
                     boxes: [{ x: 350, y: 450, width: 50, height: 50, color: '#8B4513' }], // Box
                     boulders: []
                 },
                 // Level 3 (Index 2)
                 {
                      playerStart: { x: 50, y: 400 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                          { x: 0, y: 500, width: 800, height: 100, color: '#2E8B57' },
                          { x: 0, y: 450, width: 100, height: 50, color: '#2E8B57' }, // Start platform
                          { x: 600, y: 450, width: 200, height: 50, color: '#2E8B57' }, // End platform
                     ],
                     enemies: [{ x: 250, y: 460, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 400, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 700, y: 420, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 750, y: 400, width: 10, height: 50, color: 'red' }], boxes:[],
                     boulders: [{ x: 500, y: 440, radius: 30, color: 'grey', dx: -1.5 }] // Rolling boulder
                 },
                 // Level 4 (Index 3) - Cart, Enemy on platform, Swinging bridge
                 {
                     playerStart: { x: 50, y: 400 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                         { x: 0, y: 500, width: 250, height: 100, color: '#2E8B57' }, // Start ground
                         { x: 0, y: 450, width: 100, height: 50, color: '#2E8B57' }, // Platform above start
                         { x: 300, y: 400, width: 50, height: 100, color: '#2E8B57' }, // Small column
                         { x: 600, y: 500, width: 200, height: 100, color: '#2E8B57' }, // End ground
                         // Swinging platforms need dynamic implementation
                         { x: 400, y: 450, width: 150, height: 20, color: '#A0522D', type: 'swing', swingSpeed: 0.02, angle: 0, range: Math.PI / 6 },
                     ],
                     enemies: [{ x: 650, y: 460, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 70, y: 420, width: 20, height: 20, color: 'yellow' }, { x: 315, y: 370, width: 20, height: 20, color: 'yellow' }, { x: 475, y: 400, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 750, y: 450, width: 10, height: 50, color: 'red' }],
                     boxes: [], boulders: [],
                     // Cart - represented as a box for now, needs push physics
                     movingPlatforms: [{ x: 150, y: 450, width: 80, height: 50, color: '#8B4513', isCart: true }]
                 },
                  // Level 5 (Index 4) - Boulder puzzle, Water
                 {
                     playerStart: { x: 50, y: 450 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                         { x: 0, y: 500, width: 200, height: 100, color: '#2E8B57' },
                         { x: 200, y: 550, width: 400, height: 50, color: 'blue' }, // Water
                         { x: 600, y: 500, width: 200, height: 100, color: '#2E8B57' },
                         { x: 300, y: 400, width: 100, height: 20, color: '#2E8B57' }, // Platform over water
                         { x: 450, y: 350, width: 100, height: 20, color: '#2E8B57' }, // Higher platform
                     ],
                     enemies: [{ x: 650, y: 460, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 350, y: 370, width: 20, height: 20, color: 'yellow' }, { x: 500, y: 320, width: 20, height: 20, color: 'yellow' }],
                     hazards: [{ x: 200, y: 500, width: 400, height: 100, color: '#6495ED' }], // Water graphic overlay
                     goals: [{ x: 750, y: 450, width: 10, height: 50, color: 'red' }],
                     boxes: [],
                     boulders: [{ x: 100, y: 450, radius: 30, color: 'grey', dx: 0 }] // Boulder to push
                 },
                 // Level 6 (Index 5) - See-saw, Cart puzzle
                 {
                     playerStart: { x: 50, y: 400 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                      platforms: [
                         { x: 0, y: 500, width: 150, height: 100, color: '#2E8B57' }, // Start
                         { x: 350, y: 500, width: 150, height: 100, color: '#2E8B57' }, // Middle
                         { x: 650, y: 500, width: 150, height: 100, color: '#2E8B57' }, // End
                         { x: 550, y: 450, width: 100, height: 20, color: '#2E8B57' }, // Platform for cart goal
                     ],
                     enemies: [{ x: 400, y: 460, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 100, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 450, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 700, y: 470, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 770, y: 450, width: 10, height: 50, color: 'red' }],
                     boxes: [{ x: 200, y: 450, width: 50, height: 50, color: '#8B4513' }],
                     boulders: [],
                     seeSaws: [{ x: 175, y: 500, width: 150, height: 10, color: '#A0522D', pivotX: 250, angle: 0 }],
                     movingPlatforms: [{ x: 450, y: 450, width: 80, height: 50, color: '#8B4513', isCart: true }] // Cart
                 },
                 // Level 7 (Index 6) - Zipline, Hammer
                 {
                     playerStart: { x: 50, y: 150 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                         { x: 0, y: 200, width: 150, height: 400, color: '#2E8B57' }, // Start Cliff
                         { x: 650, y: 200, width: 150, height: 400, color: '#2E8B57' }, // End Cliff
                         { x: 300, y: 400, width: 200, height: 200, color: '#2E8B57' }, // Middle platform
                         // Hammer obstacle needs dynamic implementation (swinging)
                          { x: 400, y: 300, width: 100, height: 20, color: '#A0522D', type: 'hammerBase' },
                          { x: 450, y: 300, width: 20, height: 60, color: 'grey', type: 'hammerHead', angle: 0, swingSpeed: 0.03, range: Math.PI / 3 }
                     ],
                      enemies: [{ x: 350, y: 360, width: 40, height: 40, color: '#555', type:'square' }, { x: 700, y: 160, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 100, y: 170, width: 20, height: 20, color: 'yellow' }, { x: 450, y: 500, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 750, y: 150, width: 10, height: 50, color: 'red' }],
                     boxes: [], boulders: [],
                     // Zipline needs dynamic implementation
                     movingPlatforms: [{ type: 'zipline', startX: 140, endX: 660, y: 180, speed: 2, currentX: 140, direction: 1, width: 50, height: 30, color:'#8B4513' }]
                 },
                  // Level 8 (Index 7) - Bridge building, Verticality
                 {
                     playerStart: { x: 50, y: 450 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                         { x: 0, y: 500, width: 200, height: 100, color: '#2E8B57' }, // Start ground
                         { x: 200, y: 500, width: 100, height: 20, color: '#A0522D', type:'bridgeSupport' }, // Bridge support left
                         { x: 400, y: 500, width: 100, height: 20, color: '#A0522D', type:'bridgeSupport' }, // Bridge support right
                         { x: 500, y: 500, width: 300, height: 100, color: '#2E8B57' }, // End ground
                         { x: 600, y: 400, width: 100, height: 20, color: '#2E8B57' }, // Upper platform 1
                         { x: 750, y: 300, width: 50, height: 200, color: '#2E8B57' }, // Upper platform 2 (pillar)
                     ],
                     enemies: [{ x: 550, y: 460, width: 40, height: 40, color: '#555', type:'square' }, { x: 630, y: 360, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 100, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 350, y: 450, width: 20, height: 20, color: 'yellow' }, { x: 700, y: 370, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 770, y: 250, width: 10, height: 50, color: 'red' }],
                     boxes: [{ x: 100, y: 400, width: 150, height: 15, color: '#A0522D', isPlank: true }], // Bridge Plank
                     boulders: []
                 },
                  // Level 9 (Index 8) - See-saw puzzle, Precision jumping
                 {
                      playerStart: { x: 50, y: 150 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                          { x: 0, y: 200, width: 100, height: 400, color: '#2E8B57' }, // Start cliff
                          { x: 250, y: 500, width: 100, height: 100, color: '#2E8B57' }, // Mid lower platform
                          { x: 550, y: 500, width: 100, height: 100, color: '#2E8B57' }, // Mid lower platform 2
                          { x: 700, y: 400, width: 100, height: 200, color: '#2E8B57' }, // End cliff
                          { x: 350, y: 350, width: 150, height: 20, color: '#2E8B57' }, // Upper middle platform
                     ],
                      enemies: [{ x: 400, y: 310, width: 40, height: 40, color: '#555', type:'square' }, { x: 720, y: 360, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 300, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 600, y: 470, width: 20, height: 20, color: 'yellow' }, { x: 425, y: 300, width: 20, height: 20, color: 'yellow' }],
                     hazards: [], goals: [{ x: 750, y: 350, width: 10, height: 50, color: 'red' }],
                     boxes: [{ x: 150, y: 480, width: 50, height: 50, color: '#8B4513' }], // Box on see-saw side
                     boulders: [],
                     seeSaws: [{ x: 125, y: 500, width: 200, height: 10, color: '#A0522D', pivotX: 225, angle: 0 }] // See-saw
                 },
                 // Level 10 (Index 9) - Catapult, Water wheel, See-saw end
                 {
                      playerStart: { x: 50, y: 150 },
                     bgColor: 'linear-gradient(to bottom, #87CEEB, #ADD8E6)',
                     platforms: [
                          { x: 0, y: 200, width: 100, height: 400, color: '#2E8B57' }, // Start cliff
                          { x: 300, y: 550, width: 400, height: 50, color: 'blue' }, // Water
                          { x: 700, y: 500, width: 100, height: 100, color: '#2E8B57' }, // Platform after water
                          { x: 800, y: 400, width: 100, height: 200, color: '#2E8B57' }, // End cliff (adjust x if needed)
                          { x: 500, y: 400, width: 100, height: 20, color: '#A0522D' }, // Platform over water wheel
                     ],
                     enemies: [{ x: 730, y: 460, width: 40, height: 40, color: '#555', type:'square' }, { x: 830, y: 360, width: 40, height: 40, color: '#555', type:'square' }],
                     stars: [{ x: 150, y: 170, width: 20, height: 20, color: 'yellow' }, { x: 450, y: 400, width: 20, height: 20, color: 'yellow' }, { x: 650, y: 400, width: 20, height: 20, color: 'yellow' }],
                     hazards: [{ x: 300, y: 500, width: 400, height: 100, color: '#6495ED' }], // Water overlay
                     goals: [{ x: 850, y: 350, width: 10, height: 50, color: 'red' }],
                     boxes: [{ x: 720, y: 400, width: 50, height: 50, color: '#8B4513' }], // Box for see-saw
                     boulders: [],
                      // Catapult (simplified - just a platform that gives boost)
                     catapults: [{ x: 50, y: 190, width: 100, height: 10, color: '#A0522D', launchPower: 20 }],
                     waterWheels: [{ x: 400, y: 450, radius: 70, color: '#A0522D', angle: 0, speed: 0.01, numPaddles: 6 }],
                     seeSaws: [{ x: 700, y: 500, width: 150, height: 10, color: '#A0522D', pivotX: 775, angle: Math.PI / 12 }] // End see-saw
                 }
             ],
             // World 1: Deep Forest (Levels 11-20) - Placeholder
             [],
             // World 2: Box Factory (Levels 21-30) - Placeholder
             [],
              // World 3: Battle for the Moon (Levels 31-40) - Placeholder
             [],
             // World 4: Into the Caves (Levels 41-50) - Placeholder
             []
        ];

        function loadLevel(levelIdx) {
            if (levelIdx < 0 || levelIdx >= levels[currentWorldIndex].length) {
                console.error("Invalid level index:", levelIdx);
                 goToScreen('levelSelect'); // Go back to level select if invalid
                return;
            }
            currentLevelIndex = levelIdx;
            levelCompleteStatus = false;
            const levelData = levels[currentWorldIndex][levelIdx];

            console.log("Loading Level:", levelIdx + 1);

             // Deep copy objects to avoid modifying original level data
            platforms = JSON.parse(JSON.stringify(levelData.platforms || []));
            enemies = JSON.parse(JSON.stringify(levelData.enemies || []));
            stars = JSON.parse(JSON.stringify(levelData.stars || []));
            hazards = JSON.parse(JSON.stringify(levelData.hazards || []));
            goals = JSON.parse(JSON.stringify(levelData.goals || []));
            boxes = JSON.parse(JSON.stringify(levelData.boxes || []));
            boulders = JSON.parse(JSON.stringify(levelData.boulders || []));
            movingPlatforms = JSON.parse(JSON.stringify(levelData.movingPlatforms || []));
            seeSaws = JSON.parse(JSON.stringify(levelData.seeSaws || []));
            catapults = JSON.parse(JSON.stringify(levelData.catapults || []));
             waterWheels = JSON.parse(JSON.stringify(levelData.waterWheels || []));


            resetPlayerPosition();
            score = 0; // Reset score for the new level
            totalStarsInLevel = stars.length;
            updateScoreBar();
            updateLevelDisplay();

            // Set background
            gameContainer.style.background = levelData.bgColor || 'lightblue';

            gameState = 'playing';
            isPaused = false;
            hideScreen(levelSelectScreen);
            hideScreen(pauseMenuScreen);
            hideScreen(gameOverMenuScreen);
            showHud();
            startGameLoop();
        }


        // --- Game Loop ---
        function update() {
            if (isPaused || gameState !== 'playing') return;

            // Player Movement
            player.dx = 0;
            if (keys['arrowleft'] || keys['a']) {
                player.dx = -player.speed;
            }
            if (keys['arrowright'] || keys['d']) {
                player.dx = player.speed;
            }
            if ((keys['arrowup'] || keys['w'] || keys[' ']) && player.onGround) {
                player.dy = -player.jumpPower;
                player.onGround = false;
                sounds.jump();
            }

             // Apply physics
             applyGravity(player);

             // Update positions
             player.x += player.dx;
             player.y += player.dy;


             // Update enemies (basic movement placeholder)
             enemies.forEach(e => {
                 if (e.patrolRange) {
                     if (!e.patrolStartX) e.patrolStartX = e.x; // Initialize patrol start
                     if (!e.patrolDir) e.patrolDir = 1;
                     e.x += e.patrolSpeed * e.patrolDir;
                     if (e.x > e.patrolStartX + e.patrolRange || e.x < e.patrolStartX) {
                         e.patrolDir *= -1; // Reverse direction
                     }
                 }
             });

             // Update other dynamic objects (moving platforms, etc.)
             movingPlatforms.forEach(p => {
                 if (p.type === 'zipline') {
                      p.currentX += p.speed * p.direction;
                      if (p.currentX > p.endX || p.currentX < p.startX) {
                          p.direction *= -1;
                      }
                      // Simple collision: If player is roughly on it, move player too
                      if (player.onGround && checkCircleRectCollision(player, {x: p.currentX, y: p.y, width: p.width, height:p.height})) {
                          player.x += p.speed * p.direction;
                      }
                 }
             });
             seeSaws.forEach(s => {
                  // Basic SeeSaw logic: tilt based on player weight (needs refinement)
                 let targetAngle = 0;
                 if (checkCircleRectCollision(player, {...s, y: s.y - 5})) { // Check slightly above
                    const relativePos = player.x - s.pivotX;
                    targetAngle = -relativePos / (s.width / 2) * (Math.PI / 8); // Max tilt pi/8 radians
                 }
                 // Smooth angle transition
                 s.angle += (targetAngle - s.angle) * 0.1;
             });
             waterWheels.forEach(w => {
                 w.angle += w.speed;
             });


             handleCollisions(); // Handle collisions after potential position updates

            // Update player eye pupils based on movement direction
             const targetPupilX = player.dx === 0 ? 0 : (player.dx > 0 ? 3 : -3);
             const targetPupilY = player.dy === 0 ? 0 : (player.dy > 0 ? 3 : -3);
             player.eyes.forEach(eye => {
                 eye.pupilOffsetX += (targetPupilX - eye.pupilOffsetX) * 0.2;
                 eye.pupilOffsetY += (targetPupilY - eye.pupilOffsetY) * 0.2;
             });
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Background Elements (if not handled by CSS background)
            // e.g., Draw parallax layers here if needed

             // Draw Water (simple rect for now)
             hazards.forEach(h => {
                 ctx.fillStyle = h.color || 'blue';
                 ctx.fillRect(h.x, h.y, h.width, h.height);
             });


             // Draw Platforms
             platforms.forEach(p => {
                 ctx.fillStyle = p.color || '#2E8B57'; // Default green
                 ctx.fillRect(p.x, p.y, p.width, p.height);
                  // Draw swinging platform if type matches
                 if (p.type === 'swing') {
                     p.angle += p.swingSpeed;
                      const pivotX = p.x + p.width / 2;
                      const pivotY = p.y - 30; // Assume rope length
                      const currentAngle = Math.sin(p.angle) * p.range;
                      const platformX = pivotX + Math.sin(currentAngle) * 30 - p.width / 2;
                      const platformY = pivotY + Math.cos(currentAngle) * 30;

                      ctx.strokeStyle = '#8B4513'; // Rope color
                      ctx.lineWidth = 2;
                      ctx.beginPath();
                      ctx.moveTo(p.x + 10, p.y - 30); // Anchor point left
                      ctx.lineTo(platformX + 10, platformY);
                      ctx.stroke();
                       ctx.beginPath();
                      ctx.moveTo(p.x + p.width -10, p.y - 30); // Anchor point right
                      ctx.lineTo(platformX + p.width - 10, platformY);
                      ctx.stroke();

                      ctx.fillStyle = p.color || '#A0522D';
                      ctx.fillRect(platformX, platformY, p.width, p.height);

                      // Update platform position for collision (crude)
                       p.x = platformX;
                       p.y = platformY;
                  } else if (p.type === 'hammerHead') {
                      // Draw hammer (basic swinging rect)
                      const baseX = p.x - 20; // Base assumed from head position
                      const baseY = p.y;
                      const pivotX = baseX + 50; // Center of hammerBase
                      const pivotY = baseY + 10;
                      const length = 80; // Hammer handle length
                      const currentAngle = Math.PI/2 + Math.sin(p.angle) * p.range; // Start vertical, swing side to side
                       p.angle += p.swingSpeed;

                      const headX = pivotX + Math.cos(currentAngle) * length - p.width/2;
                      const headY = pivotY + Math.sin(currentAngle) * length - p.height/2;

                      ctx.strokeStyle = '#8B4513'; // Handle color
                      ctx.lineWidth = 8;
                       ctx.beginPath();
                       ctx.moveTo(pivotX, pivotY);
                       ctx.lineTo(headX + p.width/2, headY + p.height/2);
                       ctx.stroke();

                       ctx.fillStyle = p.color || 'grey';
                       ctx.fillRect(headX, headY, p.width, p.height);
                       // Update position for collision
                       p.x = headX;
                       p.y = headY;
                  }
             });

             // Draw Boxes
             boxes.forEach(b => {
                 ctx.fillStyle = b.color || '#8B4513'; // Brown
                 ctx.fillRect(b.x, b.y, b.width, b.height);
                 ctx.strokeStyle = 'black';
                 ctx.lineWidth = 2;
                 ctx.strokeRect(b.x, b.y, b.width, b.height);
                 // Draw planks detail
                 ctx.beginPath();
                 ctx.moveTo(b.x, b.y + b.height / 3);
                 ctx.lineTo(b.x + b.width, b.y + b.height / 3);
                 ctx.moveTo(b.x, b.y + 2 * b.height / 3);
                 ctx.lineTo(b.x + b.width, b.y + 2 * b.height / 3);
                 ctx.moveTo(b.x + b.width/2, b.y);
                 ctx.lineTo(b.x + b.width/2, b.y + b.height);
                 ctx.stroke();

             });

             // Draw Boulders
             boulders.forEach(b => {
                 ctx.fillStyle = b.color || 'grey';
                 ctx.beginPath();
                 ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.strokeStyle = 'black';
                 ctx.lineWidth = 1;
                 ctx.stroke();
                 // Simple rolling simulation
                 b.x += b.dx;
                 // Basic gravity/stopping
                 let boulderOnGround = false;
                 platforms.concat(boxes).forEach(p => {
                     if (b.x > p.x && b.x < p.x + p.width && b.y + b.radius >= p.y && b.y + b.radius < p.y + 10) {
                         boulderOnGround = true;
                         b.y = p.y - b.radius; // Settle on ground
                     }
                 });
                 if (!boulderOnGround) {
                      b.y += 2; // Gravity if not on ground
                 } else {
                      b.dx *= 0.99; // Friction
                      if (Math.abs(b.dx) < 0.1) b.dx = 0;
                 }
                 // Collision with player (basic - kills player)
                 const playerRect = { x: player.x - player.radius, y: player.y - player.radius, width: player.width, height: player.height };
                  if (checkCircleRectCollision({x:b.x, y:b.y, radius: b.radius}, playerRect)){
                      handlePlayerDeath();
                  }
             });

             // Draw Moving Platforms (Zipline Example)
             movingPlatforms.forEach(p => {
                  if (p.type === 'zipline') {
                      ctx.fillStyle = p.color || '#8B4513';
                      ctx.fillRect(p.currentX, p.y, p.width, p.height); // Gondola
                      ctx.strokeStyle = '#555'; // Rope
                      ctx.lineWidth = 3;
                       ctx.beginPath();
                       ctx.moveTo(p.startX - 10, p.y - 5); // Anchor left
                       ctx.lineTo(p.endX + 10, p.y - 5); // Anchor right
                       ctx.stroke();
                      ctx.lineWidth = 1;
                      ctx.beginPath();
                       ctx.moveTo(p.currentX + p.width / 2, p.y); // Gondola top center
                       ctx.lineTo(p.currentX + p.width / 2, p.y - 5); // Connect to rope
                       ctx.stroke();
                  } else if (p.isCart) {
                       ctx.fillStyle = p.color || '#8B4513'; // Brown
                       ctx.fillRect(p.x, p.y, p.width, p.height);
                       ctx.strokeStyle = 'black';
                       ctx.lineWidth = 2;
                       ctx.strokeRect(p.x, p.y, p.width, p.height);
                       // Wheels
                       ctx.fillStyle = '#555';
                       ctx.beginPath();
                       ctx.arc(p.x + p.width * 0.2, p.y + p.height + 5, 8, 0, Math.PI*2); // Left wheel
                       ctx.fill();
                       ctx.beginPath();
                       ctx.arc(p.x + p.width * 0.8, p.y + p.height + 5, 8, 0, Math.PI*2); // Right wheel
                       ctx.fill();
                  }
             });

              // Draw SeeSaws
             seeSaws.forEach(s => {
                  ctx.save();
                  ctx.translate(s.pivotX, s.y); // Translate to pivot point
                  ctx.rotate(s.angle);
                  ctx.fillStyle = s.color || '#A0522D';
                  ctx.fillRect(-s.width / 2, -s.height / 2, s.width, s.height); // Draw centered on pivot
                  ctx.restore();
                  // Draw pivot triangle
                  ctx.fillStyle = 'grey';
                   ctx.beginPath();
                   ctx.moveTo(s.pivotX - 10, s.y + 15);
                   ctx.lineTo(s.pivotX + 10, s.y + 15);
                   ctx.lineTo(s.pivotX, s.y + s.height/2);
                   ctx.closePath();
                   ctx.fill();
             });

             // Draw Water Wheels
             waterWheels.forEach(w => {
                 ctx.save();
                 ctx.translate(w.x, w.y);
                 ctx.rotate(w.angle);
                 ctx.fillStyle = w.color || '#A0522D';
                 ctx.strokeStyle = 'black';
                 ctx.lineWidth = 2;

                 // Draw paddles
                 for (let i = 0; i < w.numPaddles; i++) {
                     const angle = (i / w.numPaddles) * Math.PI * 2;
                     const paddleWidth = 50;
                     const paddleHeight = 15;
                      ctx.save();
                      ctx.rotate(angle);
                      ctx.translate(w.radius - paddleHeight / 2, 0); // Position paddle at radius
                      ctx.fillRect(-paddleHeight / 2, -paddleWidth / 2, paddleHeight, paddleWidth);
                      ctx.strokeRect(-paddleHeight / 2, -paddleWidth / 2, paddleHeight, paddleWidth);

                      // Check collision with this specific paddle for player standing
                       let paddleWorldX = w.x + (w.radius - paddleHeight / 2) * Math.cos(w.angle + angle);
                       let paddleWorldY = w.y + (w.radius - paddleHeight / 2) * Math.sin(w.angle + angle);
                       // Crude AABB for rotated paddle (needs improvement)
                       const collisionRect = {x: paddleWorldX - paddleWidth/2, y: paddleWorldY-paddleWidth/2, width: paddleWidth, height: paddleWidth}; // Treat as square for simplicity
                       if(checkCircleRectCollision(player, collisionRect) && player.y + player.radius < paddleWorldY + 5){
                            player.onGround = true;
                            player.y = paddleWorldY - player.radius - paddleWidth/2; // Adjust based on rotation? Simplistic for now.
                            player.dy=0;
                            // Move player with wheel (approximate)
                            player.x += w.speed * (w.radius * Math.cos(w.angle + angle + Math.PI/2));
                            player.y += w.speed * (w.radius * Math.sin(w.angle + angle + Math.PI/2));

                       }


                      ctx.restore();
                 }
                 // Draw center hub (optional)
                 ctx.beginPath();
                 ctx.arc(0, 0, 10, 0, Math.PI * 2);
                 ctx.fillStyle = '#555';
                 ctx.fill();
                 ctx.stroke();
                 ctx.restore();
             });

              // Draw Catapults (simple plank look)
              catapults.forEach(c => {
                  ctx.fillStyle = c.color || '#A0522D';
                  ctx.fillRect(c.x, c.y, c.width, c.height);
                   // Check if player lands on it
                   if (checkCircleRectCollision(player, c) && player.dy > 0 && (player.y + player.radius) >= c.y && (player.y - player.dy + player.radius) < c.y) {
                       player.dy = -c.launchPower; // Launch!
                       player.onGround = false;
                        console.log("Catapult launch!");
                   }
              });


            // Draw Enemies
            enemies.forEach(e => {
                 ctx.fillStyle = e.color || '#555'; // Dark Gray
                 ctx.fillRect(e.x, e.y, e.width, e.height);
                 ctx.strokeStyle = 'black';
                 ctx.lineWidth = 2;
                 ctx.strokeRect(e.x, e.y, e.width, e.height);

                 // Draw simple angry face
                 ctx.fillStyle = '#FFDC00'; // Yellow eyes
                 ctx.fillRect(e.x + 5, e.y + 5, 8, 8); // Left eye
                 ctx.fillRect(e.x + e.width - 13, e.y + 5, 8, 8); // Right eye
                  ctx.fillStyle = 'black'; // Pupils
                 ctx.fillRect(e.x + 8, e.y + 8, 3, 3);
                 ctx.fillRect(e.x + e.width - 10, e.y + 8, 3, 3);
                 // Angry brows
                 ctx.lineWidth = 2;
                 ctx.beginPath();
                 ctx.moveTo(e.x + 3, e.y + 4);
                 ctx.lineTo(e.x + 15, e.y + 9);
                 ctx.moveTo(e.x + e.width - 3, e.y + 4);
                 ctx.lineTo(e.x + e.width - 15, e.y + 9);
                 ctx.stroke();
                 // Mouth (simple line)
                  ctx.beginPath();
                  ctx.moveTo(e.x + 10, e.y + e.height - 10);
                  ctx.lineTo(e.x + e.width - 10, e.y + e.height - 15);
                  ctx.stroke();
            });

            // Draw Stars
            stars.forEach(s => {
                 // Draw simple star emoji or shape
                 ctx.font = "20px Arial";
                 ctx.fillStyle = s.color || 'yellow';
                 ctx.fillText("⭐", s.x, s.y + s.height); // Adjust position based on emoji rendering
            });

            // Draw Goal
            goals.forEach(g => {
                 // Pole
                 ctx.fillStyle = 'grey';
                 ctx.fillRect(g.x, g.y, 5, g.height);
                 // Flag (triangle)
                 ctx.fillStyle = g.color || 'red';
                 ctx.beginPath();
                 ctx.moveTo(g.x + 5, g.y);
                 ctx.lineTo(g.x + 5, g.y + 15);
                 ctx.lineTo(g.x + 25, g.y + 7.5);
                 ctx.closePath();
                 ctx.fill();
            });

             // Draw Player
             ctx.fillStyle = player.color;
             ctx.beginPath();
             ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
             ctx.fill();
             ctx.strokeStyle = 'black';
             ctx.lineWidth = 2;
             ctx.stroke();
             // Draw eyes
             player.eyes.forEach(eye => {
                 const eyeX = player.x + eye.offsetX;
                 const eyeY = player.y + eye.offsetY;
                 ctx.fillStyle = 'white';
                 ctx.beginPath();
                 ctx.ellipse(eyeX, eyeY, 8, 10, 0, 0, Math.PI * 2); // Oval eyes
                 ctx.fill();
                 ctx.stroke();
                  // Draw pupil
                  ctx.fillStyle = 'black';
                  ctx.beginPath();
                  ctx.arc(eyeX + eye.pupilOffsetX, eyeY + eye.pupilOffsetY, 4, 0, Math.PI * 2);
                  ctx.fill();
             });


            // HUD is handled by DOM elements outside canvas
        }

        function gameLoop() {
            update();
            draw();
            if (gameState === 'playing' || gameState === 'paused') { // Keep looping if playing or paused (draw still needed for pause)
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        function startGameLoop() {
            if (gameLoopId) cancelAnimationFrame(gameLoopId); // Stop previous loop if any
             levelCompleteStatus = false; // Reset just in case
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        function stopGameLoop() {
             if (gameLoopId) cancelAnimationFrame(gameLoopId);
             gameLoopId = null;
        }


        // --- Screen Management ---
        function showScreen(screenElement) {
             // Hide all screens first
             document.querySelectorAll('.screen').forEach(s => {
                 s.classList.remove('active');
                 s.style.zIndex = 10; // Reset z-index
             });
             // Show the target screen
             screenElement.classList.add('active');
             screenElement.style.zIndex = 20; // Bring active screen to front
        }
        function hideScreen(screenElement) {
            screenElement.classList.remove('active');
            screenElement.style.zIndex = 10;
        }
         function showHud() {
             Object.values(hudElements).forEach(el => el.style.visibility = 'visible');
         }
         function hideHud() {
             Object.values(hudElements).forEach(el => el.style.visibility = 'hidden');
         }

        function goToScreen(screenName) {
             stopGameLoop(); // Stop game loop when changing screens
             hideHud(); // Hide HUD when not playing
             gameState = screenName;
             sounds.click(); // Generic click sound

             switch (screenName) {
                 case 'menu':
                     showScreen(mainMenuScreen);
                     break;
                 case 'settings':
                      updateSettingsDisplay();
                     showScreen(settingsScreen);
                     break;
                 case 'levelSelect':
                      generateLevelSelect();
                     showScreen(levelSelectScreen);
                     break;
                 case 'playing':
                      // Loading is handled by loadLevel which sets gameState to 'playing'
                     // showHud(); // Already handled in loadLevel
                     // startGameLoop(); // Already handled in loadLevel
                     break;
                  // Other states like 'paused', 'gameOver' are handled within game logic
             }
         }

        // --- UI Updates ---
        function updateLivesDisplay() {
             hudElements.lives.textContent = '❤️'.repeat(lives);
         }
         function updateLevelDisplay() {
             hudElements.level.textContent = `LEVEL ${String(currentLevelIndex + 1).padStart(2, '0')}`;
         }
         function updateScoreBar() {
             const starsCollected = totalStarsInLevel - stars.length;
             const percentage = totalStarsInLevel > 0 ? (starsCollected / totalStarsInLevel) * 100 : 0;
             hudElements.scoreFill.style.width = `${percentage}%`;
         }
         function updateSettingsDisplay() {
             document.getElementById('setting-music').textContent = musicOn ? 'ON' : 'OFF';
             document.getElementById('setting-sound').textContent = soundOn ? 'ON' : 'OFF';
         }


        // --- Level Select Generation ---
        const levelsPerWorld = 15;
        const worldNames = ["1. GREEN HILLS", "2. DEEP FOREST", "3. BOX FACTORY", "4. BATTLE FOR THE MOON", "5. INTO THE CAVES"];

         function generateLevelSelect() {
            const grid = document.getElementById('level-grid');
            const pagination = document.getElementById('level-select-pagination');
            const worldTitle = document.getElementById('world-title');
            grid.innerHTML = ''; // Clear previous buttons
             pagination.innerHTML = ''; // Clear previous dots

            worldTitle.textContent = worldNames[currentWorldIndex];

             const startLevel = currentWorldIndex * levelsPerWorld;
             // Only show levels that actually exist in our defined `levels` array for the current world
             const availableLevelsInWorld = levels[currentWorldIndex]?.length || 0;
             const endLevel = Math.min(startLevel + levelsPerWorld, startLevel + availableLevelsInWorld); // Cap at available levels

             for (let i = startLevel; i < startLevel + levelsPerWorld; i++) {
                 const levelNum = i + 1;
                 const button = document.createElement('button');
                 button.classList.add('button', 'level-button');
                  // Check if this level index exists for the current world
                  if (i < endLevel) {
                     button.textContent = levelNum;
                     button.onclick = () => {
                         sounds.click();
                         loadLevel(i - startLevel); // Load level relative to world start
                     };
                      // Add coin placeholder (logic for completion needed)
                      // const coin = document.createElement('span');
                      // coin.classList.add('level-coin');
                      // coin.textContent = '🪙'; // Or '⭐' or ''
                      // button.appendChild(coin);
                 } else {
                     button.textContent = ''; // Empty button for non-existent levels
                     button.style.backgroundColor = '#ccc'; // Grey out
                     button.disabled = true;
                 }
                 grid.appendChild(button);
             }

             // Pagination Dots
             const numWorlds = worldNames.length; // Use actual number of defined world names
             for(let i = 0; i < numWorlds; i++) {
                 const dot = document.createElement('div');
                 dot.classList.add('pagination-dot');
                 if (i === currentWorldIndex) {
                     dot.classList.add('active');
                 }
                 pagination.appendChild(dot);
             }

             // Update nav buttons state
              document.getElementById('world-prev').disabled = (currentWorldIndex === 0);
              // Disable next if it's the last world OR if the next world has no levels defined yet
              document.getElementById('world-next').disabled = (currentWorldIndex >= worldNames.length - 1 || (levels[currentWorldIndex + 1] && levels[currentWorldIndex + 1].length === 0) );

         }


        // --- Pause Logic ---
        function togglePause() {
             if (gameState === 'levelEnd' || gameState === 'gameOver') return; // Don't pause on these screens

             isPaused = !isPaused;
             gameState = isPaused ? 'paused' : 'playing';
             sounds.click();

             if (isPaused) {
                 // Stop game logic updates but keep drawing
                 // stopGameLoop(); // Don't stop, just prevent update logic
                 showScreen(pauseMenuScreen);
                  document.getElementById('pause-sound').textContent = soundOn ? '🔊' : '🔇';
             } else {
                 hideScreen(pauseMenuScreen);
                  startGameLoop(); // Ensure loop is running if it was stopped
             }
         }


        // --- Event Listeners for UI ---
        // Main Menu
        document.getElementById('main-menu-play').onclick = () => goToScreen('levelSelect');
        document.getElementById('main-menu-settings').onclick = () => goToScreen('settings');

        // Settings
         document.getElementById('setting-music').onclick = () => {
             musicOn = !musicOn;
             updateSettingsDisplay();
             sounds.click();
             console.log("Music Toggled:", musicOn);
             // Add actual music handling here
         };
         document.getElementById('setting-sound').onclick = () => {
             soundOn = !soundOn;
              updateSettingsDisplay();
             sounds.click();
             console.log("Sound Toggled:", soundOn);
         };
         document.getElementById('settings-back-button').onclick = () => goToScreen('menu');

         // Level Select Navigation
         document.getElementById('world-prev').onclick = () => {
             if (currentWorldIndex > 0) {
                 currentWorldIndex--;
                 generateLevelSelect();
                 sounds.click();
             }
         };
          document.getElementById('world-next').onclick = () => {
             // Only allow next if levels exist for that world
             if (currentWorldIndex < worldNames.length - 1 && levels[currentWorldIndex + 1] && levels[currentWorldIndex + 1].length > 0) {
                  currentWorldIndex++;
                  generateLevelSelect();
                 sounds.click();
              }
          };
          document.getElementById('level-select-back-button').onclick = () => goToScreen('menu');


         // Pause Menu
         document.getElementById('pause-resume').onclick = togglePause;
         document.getElementById('pause-restart').onclick = restartLevel;
         document.getElementById('pause-level-select').onclick = () => goToScreen('levelSelect');
         document.getElementById('pause-sound').onclick = () => {
             soundOn = !soundOn;
             document.getElementById('pause-sound').textContent = soundOn ? '🔊' : '🔇';
             sounds.click();
         };

         // Game Over / Level End Menu
         document.getElementById('game-over-restart').onclick = restartLevel;
          document.getElementById('game-over-continue').onclick = () => {
              sounds.click();
              hideScreen(gameOverMenuScreen);
              if (levelCompleteStatus) {
                  const nextLevel = currentLevelIndex + 1;
                   if (nextLevel < levels[currentWorldIndex].length) {
                      loadLevel(nextLevel);
                  } else {
                      // Optionally move to next world or show "World Complete"
                      console.log("World Complete! Going back to level select.");
                      goToScreen('levelSelect');
                  }
              } else {
                  // If continue was pressed after death (not level complete)
                  restartLevel(); // Or implement checkpoint logic
              }
          };
          document.getElementById('game-over-menu-btn').onclick = () => goToScreen('levelSelect'); // Go to level select instead of main menu

        // HUD Pause Button
        hudElements.pauseBtn.onclick = togglePause;


        // --- Initial Setup ---
        function initGame() {
            console.log("Initializing Game");
            hideHud(); // Hide HUD initially
            goToScreen('menu'); // Start at the main menu
        }

        initGame();

    </script>
</body>
</html>