<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>European Platformer Adventure</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
        }
        canvas {
            border: 1px solid black;
            background-color: #87CEEB; /* Sky Blue */
        }
        #controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
        }
        #levelInfo {
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="levelInfo">Level 1: Albania</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="controls">
        <button id="skipButton">Skip Level</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelInfoDiv = document.getElementById('levelInfo');
        const skipButton = document.getElementById('skipButton');

        const TILE_SIZE = 32;
        const GRAVITY = 0.5;
        const PLAYER_SPEED = 5;
        const JUMP_FORCE = 12;
        const PLAYER_SIZE = TILE_SIZE * 0.8;

        let currentLevelIndex = 0;
        let keys = {};
        let camera = { x: 0, y: 0 };

        const player = {
            x: 100,
            y: 100,
            width: PLAYER_SIZE,
            height: PLAYER_SIZE,
            dx: 0,
            dy: 0,
            onGround: false,
            color: 'blue',
            canDoubleJump: false,
            hasDoubleJumped: false,
            canWallJump: false,
            canShrink: false,
            isShrunk: false,
            hasKey: false
        };

        // --- Level Data ---
        // Define tile types (simple representation)
        // 0: Empty, 1: Platform (Brown Square), 2: Hazard (Red Triangle), 3: Goal (Green Circle),
        // 4: Moving Platform H, 5: Moving Platform V, 6: Key (Yellow Emoji 🔑), 7: Door (Gray Square 🚪),
        // 8: Bouncy Pad (Purple Triangle ▲), 9: Disappearing Platform (Light Gray Square), 10: Switch (Orange Circle),
        // 11: Controlled Platform (Off), 12: Controlled Platform (On - via Switch), 13: Enemy (Simple Patrol),
        // 14: Water (Blueish area - slows), 15: Wind Zone (Right), 16: Wind Zone (Left)
        // 17: Teleporter In, 18: Teleporter Out, 19: Ice (Light Blue Square), 20: Conveyor Belt (Right), 21: Conveyor Belt (Left)
        // 22: Crumbling Block, 23: Wall Jump Surface, 24: Gravity Flip Zone (Up), 25: Gravity Flip Zone (Down)
        // 26: Fog Zone, 27: Collectible (Star Emoji ⭐), 28: Double Jump Powerup, 29: Timed Gate (Opens/Closes),
        // 30: Hidden Passage Trigger, 31: Rope/Vine (Climbable), 32: Shrink Powerup, 33: Grow Powerup,
        // 34: Laser Emitter H, 35: Laser Emitter V, 36: Size Revert Zone

        // Helper to create a basic level map string array
        function createMap(rows) {
            return rows.map(row => row.split(''));
        }

        // Simplified representation for 51 levels. Many mechanics are conceptual/map-based.
        // Real implementation requires coding each mechanic system.
        const levels = [
            // 1: Albania - Basic Platforming
            { name: "Albania", mechanic: "Basic Jump & Move", spawn: { x: 2, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                          ",
                "                          ",
                "                          ",
                "                          ",
                "         3                ",
                "        111               ",
                "                          ",
                "      111111              ",
                "                          ",
                "    111       111         ",
                "                          ",
                "  111                      ",
                "                          ",
                " 1                        ",
                "11                        ",
                "11111111111111111111111111"
            ]) },
            // 2: Andorra - Moving Platform H
            { name: "Andorra", mechanic: "Horizontal Moving Platforms", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                    3     ",
                "                   111    ",
                "                          ",
                "               4          ",
                "                          ",
                "           1111           ",
                "                          ",
                "       4                  ",
                "                          ",
                "    111                   ",
                "                          ",
                "  1                       ",
                "                          ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
            // 3: Armenia - Moving Platform V
            { name: "Armenia", mechanic: "Vertical Moving Platforms", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "            5             ",
                "                          ",
                "                          ",
                "                          ",
                "                    3     ",
                "            1      111    ",
                "                          ",
                "           111            ",
                "     5                    ",
                "                          ",
                "                          ",
                "    111                   ",
                "                          ",
                "                          ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
            // 4: Austria - Hazards
            { name: "Austria", mechanic: "Hazards (Spikes)", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                          ",
                "                          ",
                "                      3   ",
                "                     111  ",
                "                          ",
                "                1111      ",
                "              222222      ",
                "         1111             ",
                "        222222            ",
                "    111                   ",
                "   22222                  ",
                "                          ",
                "                          ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
            // 5: Azerbaijan - Keys and Doors
            { name: "Azerbaijan", mechanic: "Keys & Locked Doors", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                          ",
                "       7777          3    ",
                "       7  7         111   ",
                "       7  7               ",
                "       1111               ",
                "                          ",
                "              1111        ",
                "                          ",
                "    111                   ",
                "                          ",
                "              6           ",
                "             111          ",
                "                          ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
             // 6: Belarus - Bouncy Pads
            { name: "Belarus", mechanic: "Bouncy Pads", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                       3  ",
                "                      111 ",
                "                          ",
                "                          ",
                "                          ",
                "             111          ",
                "                          ",
                "         111              ",
                "                          ",
                "     111                  ",
                "                          ",
                "                          ",
                "    8                     ",
                "   111                    ",
                " 1                        ",
                "11111111111111111111111111"
            ]) },
            // 7: Belgium - Disappearing Platforms
            { name: "Belgium", mechanic: "Disappearing Platforms", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                         3",
                "                        111",
                "                          ",
                "                999       ",
                "                          ",
                "            111           ",
                "                          ",
                "       999                ",
                "                          ",
                "    111                   ",
                "                          ",
                "  99                      ",
                "                          ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
            // 8: Bosnia and Herzegovina - Switches
            { name: "Bosnia and Herzegovina", mechanic: "Switches & Controlled Platforms", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                    3     ",
                "                   111    ",
                "                          ",
                "         111111           ", // Wall
                "         1   11           ",
                "         1   11      11   ", // Controlled platform (11 initially off)
                "         1   11           ",
                "         10               ", // Switch
                "         11111            ",
                "                          ",
                "    111                   ",
                "                          ",
                "                          ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
             // 9: Bulgaria - Simple Enemies
            { name: "Bulgaria", mechanic: "Basic Enemies", spawn: { x: 1, y: 16 }, map: createMap([
                "                          ",
                "                          ",
                "                          ",
                "                          ",
                "                      3   ",
                "                     111  ",
                "                          ",
                "                1111      ",
                "                          ",
                "         1111             ",
                "            13            ", // Enemy
                "           1111           ",
                "    111                   ",
                "   1 3  1                 ", // Enemy
                "  1111111                 ",
                " 1                        ",
                "1                         ",
                "11111111111111111111111111"
            ]) },
            // 10: Croatia - Water (Slow)
            { name: "Croatia", mechanic: "Water (Slow Movement)", spawn: { x: 1, y: 14 }, map: createMap([
                "                          ",
                "                          ",
                "                       3  ",
                "                      111 ",
                "                          ",
                "             111          ",
                "                          ",
                "         111              ",
                "                          ",
                "                          ",
                "   111                    ",
                "                          ",
                "                          ",
                " 1     144444444441     1 ",
                "11     144444444441    11 ",
                "1111111144444444441111111 ",
                "1111111144444444441111111 ",
                "11111111111111111111111111"
            ]) },
            // --- Levels 11-50: Conceptual placeholders ---
            // These would need unique map designs and potentially new coded mechanics.
            // For brevity and feasibility, they reuse existing elements with different layouts.
            { name: "Cyprus", mechanic: "Wind Zones", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1   3                     1", "1  111                    1", "1                         1", "1      151515             1", "1      111111             1", "1                         1", "1            161616       1", "1            111111       1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Czechia", mechanic: "Teleporters", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1               18        1", "1              111        1", "1                         1", "1                         1", "1         111             1", "1                         1", "1                         1", "1   17                    1", "1  111                    1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Denmark", mechanic: "Ice Physics", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                        31", "1                       111", "1                         1", "1        1919191919       1", "1       11111111111       1", "1                         1", "1    111                  1", "1   22222                 1", "1                         1", "1 191919                  1", "1 111111                  1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Estonia", mechanic: "Conveyor Belts", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1              3          1", "1             111         1", "1                         1", "1      202020202020       1", "1      111111111111       1", "1                         1", "1               212121    1", "1              1111111    1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Finland", mechanic: "Crumbling Blocks", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1                     3   1", "1                    111  1", "1                         1", "1            2222         1", // Crumbling
                "1           1111         1", "1                         1", "1       222               1", "1      1111               1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "France", mechanic: "Wall Jumping", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1          1              1", "1          13             1", "1          111            1", "1          1              1", "1          1              1", "1          1 1            1", "1            1            1", "1            1            1", "1            1            1", "1 1          1            1", "1 1                       1", "1 1          111          1", "1 1                       1", "1 1                       1", "1                         1", "1                         1", "11111111111111111111111111"]) }, // Wall jump surfaces implicitly are '1' tiles adjacent to air
            { name: "Georgia", mechanic: "Gravity Flip", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1            3            1", "1           111           1", "1          242424         1", // Gravity Up Zone
                "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "1    111                  1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Germany", mechanic: "Limited Visibility", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1                     3   1", "1                    111  1", "1                         1", "1        26262626         1", // Fog Zone
                "1        11111111         1", "1        26262626         1", "1                         1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Greece", mechanic: "Collectibles", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1            27           1", "1           111           1", "1                         1", "1   27                    1", "1  111                    1", "1                         1", "1               27      3 1", "1              111     1111", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) }, // Goal might require collectibles
            { name: "Hungary", mechanic: "Double Jump", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1                       3 1", "1                      1111", "1                         1", "1            111          1", "1                         1", // Higher jump needed
                "1                         1", "1                         1", "1     111                 1", "1                         1", "1                         1", "1   28                    1", // Powerup
                "1  111                    1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Iceland", mechanic: "Timed Challenges", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1            3            1", "1           111           1", "1                         1", "1      292929             1", // Timed Gate
                "1      111111             1", "1                         1", "1                         1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Ireland", mechanic: "Hidden Passages", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "1   111111111111111111    1", "1   1          1       31 1", // Fake wall / Goal behind
                "1   1    30    1      111 1", // Hidden trigger
                "1   1          1          1", "1   1          1          1", "1   11111111111          1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Italy", mechanic: "Ropes/Vines", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1           3             1", "1          111            1", "1           31            1", // Vine
                "1           31            1", "1           31            1", "1           31            1", "1                         1", "1                         1", "1                         1", "1    111                  1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Kazakhstan", mechanic: "Size Change", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                     3   1", "1                    111  1", "1                         1", "1         111111          1", // Narrow passage
                "1         1   11          1", "1         133 11          1", // Grow powerup inside
                "1         111111          1", "1                         1", "1   32                    1", // Shrink powerup
                "1  111                    1", "1                         1", "1            36           1", // Revert zone
                "1           111           1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            { name: "Latvia", mechanic: "Lasers", spawn: { x: 1, y: 16 }, map: createMap([ /* Map Design */ "11111111111111111111111111", "1                         1", "1                         1", "1            3            1", "1           111           1", "1                         1", "1  34------------------>  1", // Horizontal Laser Emitter
                "1           111           1", "1                         1", "1                         1", "1                         1", "1   111                   1", "1                         1", "1                         1", "1                         1", "1                         1", "1                         1", "11111111111111111111111111"]) },
            // ... Add 24 more levels with placeholder maps and conceptual mechanics ...
            { name: "Liechtenstein", mechanic: "Complex Switches", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Lithuania", mechanic: "Advanced Moving Platforms", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Luxembourg", mechanic: "Mazes", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Malta", mechanic: "Limited Jumps", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Moldova", mechanic: "Fragile Ground", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Monaco", mechanic: "Precision Platforming", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Montenegro", mechanic: "Stealth Sections", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Netherlands", mechanic: "Rising Water/Lava", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "North Macedonia", mechanic: "Enemy Waves", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Norway", mechanic: "Blizzards (Strong Wind)", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Poland", mechanic: "Temporary Platforms", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Portugal", mechanic: "Portals (Momentum)", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Romania", mechanic: "Darkness & Light Sources", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Russia", mechanic: "Large Scale Level", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) }, // Conceptually large
            { name: "San Marino", mechanic: "Vertical Climb", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Serbia", mechanic: "Moving Hazards", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Slovakia", mechanic: "Gear/Rotating Platforms", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Slovenia", mechanic: "Cave Exploration", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Spain", mechanic: "Heat/Desert Effects", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Sweden", mechanic: "Building/Placing Blocks", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Switzerland", mechanic: "Neutral Zones (No Abilities)", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Turkey", mechanic: "Bazaar/Crowd Simulation", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Ukraine", mechanic: "Resource Management", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "UK", mechanic: "Weather Changes (Rain/Wind)", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            { name: "Vatican", mechanic: "Puzzle Elements", spawn: { x: 1, y: 16 }, map: createMap([...Array(17).fill("1                         1"), "11111111111111111111111111"]) },
            // 51: Nazi Germany - Combine Mechanics (Longer Level)
             { name: "Nazi Germany", mechanic: "All Mechanics Gauntlet", spawn: { x: 1, y: 30 }, map: createMap([
                // Example section combining a few implemented mechanics - Needs expansion
                "                                                                                ", // Extra Wide Map
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                                ",
                "                                                                           3    ",
                "                                                                          111   ",
                "                                                                                ",
                "                                                        1111111111111111111111  ",
                "                                                       22         2 2         2 ",
                "                                            4          11         1 1         1 ",
                "                                                       11         1 1         1 ",
                "                                        11111                      19191919   1 ",
                "                                       22222                       11111111   1 ",
                "                             1111                                               1 ",
                "                           13    1                                              1 ",
                "                          11111111                      7777                    1 ",
                "                                                        7  7                    1 ",
                "                    4                                   7  7                    1 ",
                "                                           8            1111                    1 ",
                "         1111                             111                                   1 ",
                "        22222                                                                   1 ",
                "                                   6                                            1 ",
                "                              1111111                                           1 ",
                "    111                                                                         1 ",
                "                                                                                1 ",
                "11                                                                              1 ",
                "111111111111111111111111111111111111111111111111111111111111111111111111111111111"
            ]) },
        ];


        // --- Game Objects ---
        // Simple representation for dynamic objects
        let dynamicObjects = [];

        function initLevel(levelIndex) {
            const level = levels[levelIndex];
            levelInfoDiv.textContent = `Level ${levelIndex + 1}: ${level.name} - ${level.mechanic}`;
            player.x = level.spawn.x * TILE_SIZE;
            player.y = level.spawn.y * TILE_SIZE - PLAYER_SIZE;
            player.dx = 0;
            player.dy = 0;
            player.onGround = false;
            player.hasKey = false;
            // Reset level-specific abilities/states
            player.canDoubleJump = level.mechanic.includes("Double Jump"); // Example simple check
            player.canWallJump = level.mechanic.includes("Wall Jump");
            player.canShrink = level.mechanic.includes("Size Change");
            player.isShrunk = false;
            player.width = PLAYER_SIZE;
            player.height = PLAYER_SIZE;


            dynamicObjects = [];
            const map = level.map;
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    const tile = map[y][x];
                    const objX = x * TILE_SIZE;
                    const objY = y * TILE_SIZE;

                    if (tile === '4') { // Moving Platform H
                        dynamicObjects.push({ type: 'movingPlatformH', x: objX, y: objY, width: TILE_SIZE * 3, height: TILE_SIZE, startX: objX, speed: 1, range: TILE_SIZE * 5 });
                    } else if (tile === '5') { // Moving Platform V
                         dynamicObjects.push({ type: 'movingPlatformV', x: objX, y: objY, width: TILE_SIZE * 3, height: TILE_SIZE, startY: objY, speed: 1, range: TILE_SIZE * 4 });
                    } else if (tile === '9') { // Disappearing Platform
                        dynamicObjects.push({ type: 'disappearingPlatform', x: objX, y: objY, width: TILE_SIZE, height: TILE_SIZE, originalY: objY, timer: -1, reappearTimer: -1 });
                    } else if (tile === '10') { // Switch
                        dynamicObjects.push({ type: 'switch', x: objX, y: objY, width: TILE_SIZE, height: TILE_SIZE, activated: false });
                    } else if (tile === '11') { // Controlled Platform (Off initially)
                        dynamicObjects.push({ type: 'controlledPlatform', id: `cp_${x}_${y}`, x: objX, y: objY, width: TILE_SIZE, height: TILE_SIZE, activated: false });
                    } else if (tile === '13') { // Enemy
                        dynamicObjects.push({ type: 'enemy', x: objX, y: objY, width: TILE_SIZE * 0.8, height: TILE_SIZE*0.8, startX: objX, speed: 0.5, range: TILE_SIZE * 3 });
                    }
                    // Add more dynamic object initializations here
                }
            }
        }


        function updatePlayer() {
            const level = levels[currentLevelIndex];
            const map = level.map;
            const currentMapWidth = (map[0]?.length || 0) * TILE_SIZE;
            const currentMapHeight = map.length * TILE_SIZE;

            // Apply gravity
            if (!player.onGround) {
                player.dy += GRAVITY;
            }

             // Horizontal Movement
            player.dx = 0;
            if (keys['a'] || keys['A']) {
                player.dx = -PLAYER_SPEED;
            }
            if (keys['d'] || keys['D']) {
                player.dx = PLAYER_SPEED;
            }

            // Apply horizontal movement and check collisions
            player.x += player.dx;
            handleCollision('x', map, currentMapWidth, currentMapHeight);


            // Apply vertical movement and check collisions
            player.y += player.dy;
            player.onGround = false; // Assume not on ground until collision check proves otherwise
            handleCollision('y', map, currentMapWidth, currentMapHeight);


            // Jump
            if ((keys[' '] || keys['w'] || keys['W']) && player.onGround) {
                player.dy = -JUMP_FORCE;
                player.onGround = false;
                player.hasDoubleJumped = false; // Reset double jump on ground jump
            }
             // Double Jump (if enabled and first jump done)
            else if (player.canDoubleJump && (keys[' '] || keys['w'] || keys['W']) && !player.onGround && !player.hasDoubleJumped) {
                 player.dy = -JUMP_FORCE * 0.9; // Slightly weaker double jump
                 player.hasDoubleJumped = true;
                 delete keys[' ']; // Consume jump input to prevent triple+ jumps
                 delete keys['w'];
                 delete keys['W'];
            }

             // Wall Jump (Simplified: Check if touching wall and jump)
             // A proper wall jump needs state tracking (touching left/right wall)
             if (player.canWallJump && (keys[' '] || keys['w'] || keys['W']) && !player.onGround && isTouchingWall(map)) {
                 // Determine jump direction based on which wall is closer or last input direction
                 let wallJumpDir = player.dx > 0 ? -1 : 1; // Jump away from wall (needs refinement)
                 player.dy = -JUMP_FORCE * 0.8;
                 player.dx = PLAYER_SPEED * wallJumpDir * 1.5; // Push off wall
                 // Optional: Reset double jump on wall jump if desired
                 // player.hasDoubleJumped = false;
                 delete keys[' ']; // Consume jump input
                 delete keys['w'];
                 delete keys['W'];
             }

            // Reset position if falling out of bounds
             if (player.y > currentMapHeight) {
                resetPlayerPosition();
            }

             // Keep player within horizontal bounds (optional, could allow screen wrapping)
             if (player.x < 0) player.x = 0;
             if (player.x + player.width > currentMapWidth) player.x = currentMapWidth - player.width;

            // Update camera to follow player horizontally
            // Smooth camera or center screen options could be added
             camera.x = player.x - canvas.width / 3;
             // Clamp camera position
             if (camera.x < 0) camera.x = 0;
             if (camera.x > currentMapWidth - canvas.width) camera.x = currentMapWidth - canvas.width;

             // Handle Shrink/Grow based on zones/powerups (conceptual)
             if (player.canShrink) {
                // Check for collision with shrink/grow/revert zones (Tile types 32, 33, 36)
                // Example: If touching shrink powerup (32)
                // player.isShrunk = true; player.width = PLAYER_SIZE * 0.5; player.height = PLAYER_SIZE * 0.5;
                // Example: If touching grow powerup (33) or revert zone (36)
                // player.isShrunk = false; player.width = PLAYER_SIZE; player.height = PLAYER_SIZE;
             }
        }

        function isTouchingWall(map) {
             // Simplified check - check tiles immediately left/right of player
            let tileXLeft = Math.floor((player.x - 1) / TILE_SIZE);
            let tileXRight = Math.floor((player.x + player.width + 1) / TILE_SIZE);
            let tileYTop = Math.floor(player.y / TILE_SIZE);
            let tileYBottom = Math.floor((player.y + player.height - 1) / TILE_SIZE);

            for (let ty = tileYTop; ty <= tileYBottom; ty++) {
                if (getTile(map, tileXLeft, ty) === '1' || getTile(map, tileXRight, ty) === '1') { // Basic wall tile
                    return true;
                }
            }
            return false;
        }


        function handleCollision(axis, map, mapWidth, mapHeight) {
            const isXAxis = axis === 'x';
            const isYAxis = axis === 'y';

             // Check against map tiles
            let startTileX = Math.max(0, Math.floor(player.x / TILE_SIZE));
            let endTileX = Math.min(Math.floor(mapWidth/TILE_SIZE)-1, Math.floor((player.x + player.width) / TILE_SIZE));
            let startTileY = Math.max(0, Math.floor(player.y / TILE_SIZE));
            let endTileY = Math.min(Math.floor(mapHeight/TILE_SIZE)-1, Math.floor((player.y + player.height) / TILE_SIZE));


            for (let ty = startTileY; ty <= endTileY; ty++) {
                for (let tx = startTileX; tx <= endTileX; tx++) {
                    const tile = getTile(map, tx, ty);
                    const tileX = tx * TILE_SIZE;
                    const tileY = ty * TILE_SIZE;
                    let collisionOccurred = false;

                    if (tile !== '0' && tile !== '') { // Check collision only with non-empty tiles
                         // Simple AABB collision check
                        if (player.x < tileX + TILE_SIZE &&
                            player.x + player.width > tileX &&
                            player.y < tileY + TILE_SIZE &&
                            player.y + player.height > tileY)
                        {
                            // --- Handle Collision Based on Tile Type ---
                            if (tile === '1' || tile === '19') { // Platform or Ice
                                collisionOccurred = true;
                                if (tile === '19') { /* Apply slippery effect if needed */ }
                            } else if (tile === '2') { // Hazard
                                resetPlayerPosition();
                                return; // Stop further collision checks for this frame
                            } else if (tile === '3') { // Goal
                                nextLevel();
                                return;
                            } else if (tile === '6') { // Key
                                player.hasKey = true;
                                map[ty][tx] = '0'; // Remove key from map visually
                                // Could add sound effect here
                            } else if (tile === '7') { // Door
                                if (player.hasKey) {
                                    map[ty][tx] = '0'; // Remove door from map visually
                                    // Find adjacent door parts and remove them too
                                    if (getTile(map, tx+1, ty) === '7') map[ty][tx+1] = '0';
                                    if (getTile(map, tx-1, ty) === '7') map[ty][tx-1] = '0';
                                    if (getTile(map, tx, ty+1) === '7') map[ty+1][tx] = '0';
                                    if (getTile(map, tx, ty-1) === '7') map[ty-1][tx] = '0';

                                } else {
                                    collisionOccurred = true; // Act as solid wall if no key
                                }
                            } else if (tile === '8') { // Bouncy Pad
                                if (player.dy > 0 && player.y + player.height - player.dy <= tileY) { // Bounce only when landing on top
                                     player.dy = -JUMP_FORCE * 1.5; // Extra bounce
                                     player.onGround = false; // Ensure we leave the ground state
                                } else {
                                     // Act as wall if hit from side/bottom
                                     collisionOccurred = true;
                                }
                            }
                            // Add handlers for other tile types (14: water, etc.)


                            // --- Resolve Collision ---
                            if (collisionOccurred) {
                                if (isXAxis) {
                                    if (player.dx > 0) { // Moving right
                                        player.x = tileX - player.width;
                                    } else if (player.dx < 0) { // Moving left
                                        player.x = tileX + TILE_SIZE;
                                    }
                                    player.dx = 0;
                                } else if (isYAxis) {
                                    if (player.dy > 0) { // Moving down
                                        player.y = tileY - player.height;
                                        player.dy = 0;
                                        player.onGround = true;
                                    } else if (player.dy < 0) { // Moving up
                                        player.y = tileY + TILE_SIZE;
                                        player.dy = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // --- Check against dynamic objects ---
             dynamicObjects.forEach(obj => {
                 let collisionWithDynamic = false;
                 let platformSpeedX = 0;
                 let platformSpeedY = 0;

                 if (player.x < obj.x + obj.width &&
                     player.x + player.width > obj.x &&
                     player.y < obj.y + obj.height &&
                     player.y + player.height > obj.y)
                 {
                     if (obj.type === 'movingPlatformH' || obj.type === 'movingPlatformV' || (obj.type === 'controlledPlatform' && obj.activated) || obj.type === 'disappearingPlatform') {
                         collisionWithDynamic = true;
                         if (obj.type === 'movingPlatformH') platformSpeedX = obj.speed;
                         if (obj.type === 'movingPlatformV') platformSpeedY = obj.speed; // Should be obj.dy if calculated

                         // Specific logic for disappearing platform
                         if (obj.type === 'disappearingPlatform' && obj.timer === -1 && isYAxis && player.dy > 0 && player.y + player.height - player.dy <= obj.y) {
                             obj.timer = 60; // Start disappearing timer (e.g., 1 second at 60fps)
                         }

                     } else if (obj.type === 'switch') {
                         // Activate switch only if landed on from top? Or any touch?
                         if (!obj.activated && isYAxis && player.dy > 0 && player.y + player.height - player.dy <= obj.y) {
                             obj.activated = true;
                             // Find associated controlled platforms and activate them
                             dynamicObjects.filter(o => o.type === 'controlledPlatform').forEach(cp => cp.activated = true); // Simple: activate all
                         }
                         // Switches don't usually cause collision resolution
                         collisionWithDynamic = false;
                     } else if (obj.type === 'enemy') {
                         resetPlayerPosition(); // Simple enemy collision = reset
                         return;
                     }


                     // --- Resolve Dynamic Collision ---
                     if (collisionWithDynamic) {
                          if (isXAxis) {
                            if (player.dx > 0) player.x = obj.x - player.width;
                            else if (player.dx < 0) player.x = obj.x + obj.width;
                            player.dx = 0;
                        } else if (isYAxis) {
                            if (player.dy > 0 && player.y + player.height - player.dy <= obj.y) { // Landed on top
                                player.y = obj.y - player.height;
                                player.dy = 0;
                                player.onGround = true;
                                // Stick to platform (basic implementation)
                                player.x += platformSpeedX;
                                // Y movement handled by platform update
                            } else if (player.dy < 0) { // Hit from bottom
                                player.y = obj.y + obj.height;
                                player.dy = 0;
                            }
                        }
                     }
                 }
             });

        }


        function updateDynamicObjects() {
            const map = levels[currentLevelIndex].map;
            dynamicObjects.forEach((obj, index) => {
                if (obj.type === 'movingPlatformH') {
                    obj.x += obj.speed;
                    if (obj.x <= obj.startX || obj.x >= obj.startX + obj.range) {
                        obj.speed *= -1; // Reverse direction
                    }
                } else if (obj.type === 'movingPlatformV') {
                     obj.y += obj.speed;
                     if (obj.y <= obj.startY || obj.y >= obj.startY + obj.range) {
                         obj.speed *= -1;
                     }
                 } else if (obj.type === 'disappearingPlatform') {
                     if (obj.timer > 0) {
                         obj.timer--;
                         obj.y += 2; // Visual cue: sinking
                         if (obj.timer === 0) {
                             obj.reappearTimer = 180; // Time to reappear (e.g., 3 seconds)
                         }
                     } else if (obj.reappearTimer > 0) {
                         obj.reappearTimer--;
                         if (obj.reappearTimer === 0) {
                             obj.y = obj.originalY; // Reset position
                             obj.timer = -1; // Ready to disappear again
                         }
                     }
                 } else if (obj.type === 'enemy') {
                    obj.x += obj.speed;
                    // Basic patrol: check for edges or walls
                    let nextTileX = Math.floor((obj.x + (obj.speed > 0 ? obj.width : 0)) / TILE_SIZE);
                    let groundTileY = Math.floor((obj.y + obj.height) / TILE_SIZE);
                    let wallTileY = Math.floor(obj.y / TILE_SIZE);

                    let groundAhead = getTile(map, nextTileX, groundTileY);
                    let wallAhead = getTile(map, nextTileX, wallTileY); // Check at enemy's head height too

                    if (groundAhead === '0' || groundAhead === '' || wallAhead === '1') { // Turn around if edge or wall
                       obj.speed *= -1;
                       obj.x += obj.speed * 2; // Move slightly away from edge/wall to prevent getting stuck
                    }
                    // Keep enemy within its defined range if needed (optional)
                    if (obj.range && (obj.x <= obj.startX || obj.x >= obj.startX + obj.range)) {
                        //obj.speed *= -1; // Alternative patrol logic using range
                    }
                 }
                // Add update logic for other dynamic types (controlled platforms don't move unless designed to)
            });
        }


        function getTile(map, x, y) {
            if (y >= 0 && y < map.length && x >= 0 && x < map[y].length) {
                return map[y][x];
            }
            return ''; // Out of bounds or empty implicitly
        }

        function resetPlayerPosition() {
            const level = levels[currentLevelIndex];
            player.x = level.spawn.x * TILE_SIZE;
            player.y = level.spawn.y * TILE_SIZE - PLAYER_SIZE;
            player.dx = 0;
            player.dy = 0;
            player.onGround = false;
            // Don't reset key on death? Or reset? Depends on game design. Let's reset for now.
            // player.hasKey = false;
            // Reset relevant powerup states if needed
             player.isShrunk = false;
             player.width = PLAYER_SIZE;
             player.height = PLAYER_SIZE;
             // Note: This doesn't reset the map state (like collected keys or opened doors).
             // For full reset, call initLevel(currentLevelIndex);
        }

        function nextLevel() {
            currentLevelIndex++;
            if (currentLevelIndex >= levels.length) {
                // Game completed - maybe show a message or loop
                alert("Congratulations! You've completed all levels!");
                currentLevelIndex = 0; // Loop back to start
            }
            initLevel(currentLevelIndex);
        }

        function skipLevel() {
             nextLevel();
        }


        function draw() {
            const level = levels[currentLevelIndex];
            const map = level.map;

            // Clear canvas
            ctx.fillStyle = '#87CEEB'; // Sky Blue
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply camera translation
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // --- Draw Map Tiles ---
            const startCol = Math.floor(camera.x / TILE_SIZE);
            const endCol = startCol + Math.ceil(canvas.width / TILE_SIZE) + 1;
            const startRow = Math.floor(camera.y / TILE_SIZE);
            const endRow = startRow + Math.ceil(canvas.height / TILE_SIZE) + 1;

            for (let y = startRow; y < endRow; y++) {
                for (let x = startCol; x < endCol; x++) {
                    const tile = getTile(map, x, y);
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;

                    if (tile === '1') { // Platform
                        ctx.fillStyle = '#A0522D'; // Brown
                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                    } else if (tile === '2') { // Hazard
                        ctx.fillStyle = 'red';
                        ctx.beginPath();
                        ctx.moveTo(tileX + TILE_SIZE / 2, tileY + TILE_SIZE * 0.2);
                        ctx.lineTo(tileX + TILE_SIZE * 0.1, tileY + TILE_SIZE * 0.8);
                        ctx.lineTo(tileX + TILE_SIZE * 0.9, tileY + TILE_SIZE * 0.8);
                        ctx.closePath();
                        ctx.fill();
                    } else if (tile === '3') { // Goal
                        ctx.fillStyle = 'green';
                        ctx.beginPath();
                        ctx.arc(tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2, TILE_SIZE / 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === '6') { // Key
                        ctx.fillStyle = 'yellow';
                        ctx.font = `${TILE_SIZE * 0.8}px Arial`;
                        ctx.fillText('🔑', tileX + TILE_SIZE * 0.1, tileY + TILE_SIZE * 0.8);
                    } else if (tile === '7') { // Door
                        ctx.fillStyle = '#808080'; // Gray
                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#606060';
                        ctx.fillRect(tileX + TILE_SIZE * 0.1, tileY + TILE_SIZE * 0.1, TILE_SIZE * 0.8, TILE_SIZE * 0.8); // Inner part
                         ctx.fillStyle = 'yellow'; // Keyhole
                         ctx.fillRect(tileX + TILE_SIZE * 0.4, tileY + TILE_SIZE * 0.4, TILE_SIZE * 0.2, TILE_SIZE * 0.2);
                    } else if (tile === '8') { // Bouncy Pad
                        ctx.fillStyle = 'purple';
                        ctx.beginPath();
                        ctx.moveTo(tileX + TILE_SIZE / 2, tileY + TILE_SIZE * 0.8); // Point up
                        ctx.lineTo(tileX + TILE_SIZE * 0.1, tileY + TILE_SIZE * 0.2);
                        ctx.lineTo(tileX + TILE_SIZE * 0.9, tileY + TILE_SIZE * 0.2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (tile === '19') { // Ice
                         ctx.fillStyle = '#ADD8E6'; // Light Blue
                         ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                    }
                    // Draw other static tile types...
                }
            }

             // --- Draw Dynamic Objects ---
             dynamicObjects.forEach(obj => {
                 // Check if object is within camera view before drawing
                 if (obj.x + obj.width > camera.x && obj.x < camera.x + canvas.width &&
                     obj.y + obj.height > camera.y && obj.y < camera.y + canvas.height)
                 {
                     if (obj.type === 'movingPlatformH' || obj.type === 'movingPlatformV') {
                         ctx.fillStyle = '#4682B4'; // Steel Blue
                         ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                     } else if (obj.type === 'disappearingPlatform') {
                          if (obj.reappearTimer <= 0) { // Only draw if not waiting to reappear
                            ctx.fillStyle = obj.timer > 0 ? `rgba(211, 211, 211, ${obj.timer/60})` : '#D3D3D3'; // Light Gray, fade out
                            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                          }
                     } else if (obj.type === 'switch') {
                          ctx.fillStyle = obj.activated ? 'lime' : 'orange';
                          ctx.beginPath();
                          ctx.arc(obj.x + obj.width/2, obj.y + obj.height/2, obj.width/2.5, 0, Math.PI * 2);
                          ctx.fill();
                     } else if (obj.type === 'controlledPlatform') {
                         if (obj.activated) {
                             ctx.fillStyle = '#90EE90'; // Light Green (On)
                             ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                         } else {
                              // Optionally draw faint outline when off
                              // ctx.strokeStyle = '#A9A9A9'; // Dark Gray
                              // ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                         }
                     } else if (obj.type === 'enemy') {
                        ctx.fillStyle = 'pink'; // Simple enemy color
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        // Draw eyes for direction
                        ctx.fillStyle = 'black';
                        let eyeX = obj.speed > 0 ? obj.x + obj.width * 0.6 : obj.x + obj.width * 0.1;
                        ctx.fillRect(eyeX, obj.y + obj.height * 0.2, obj.width * 0.2, obj.height * 0.2);
                     }
                     // Draw other dynamic objects...
                 }
             });


            // --- Draw Player ---
             if (player.x + player.width > camera.x && player.x < camera.x + canvas.width &&
                 player.y + player.height > camera.y && player.y < camera.y + canvas.height)
             {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
             }

            // Restore camera translation
            ctx.restore();

            // --- Draw UI elements (like key status) relative to canvas ---
            if (player.hasKey) {
                ctx.fillStyle = 'yellow';
                ctx.font = '24px Arial';
                ctx.fillText('🔑', 10, 30);
            }
        }


        function gameLoop() {
            updatePlayer();
            updateDynamicObjects();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
             // Prevent space bar from scrolling the page
             if (e.key === ' ') {
                 e.preventDefault();
             }
             // Handle reset
             if (e.key === 'r' || e.key === 'R') {
                 // resetPlayerPosition(); // Basic reset
                 initLevel(currentLevelIndex); // Full level reset
             }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        skipButton.addEventListener('click', skipLevel);


        // --- Start Game ---
        initLevel(currentLevelIndex);
        gameLoop();

    </script>

</body>
</html>